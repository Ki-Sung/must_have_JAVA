# 03 변수, 상수, 자료형의 형변환 
- 선행 학습에서 배운 변수와 상수의 개념을 확장해봅니다. 그리고 자료형의 형변환이 무엇인지 알아봅니다.
- 예제 코드는 "01_Java_Basic_Programming/code/src/Chap_02_Variables_Constants_DataTypeConversion"에서 확인하실 수 있습니다.
## 1. 변수 
**변수**(**變**: 변할 **변**, **数**: 셀 **수**)는 변하는 수를 말합니다. 코드에서 변수가 구체적으로 무엇인지와 이름 짓는 방법을 알아보겠습니다.
### 1-1. 변수의 이해
선행 학습에서 살펴본 변수에 대한 설명을 다시 보겠습니다. 
```
y = x + 1;
```
x값이 2면 y값은 3이 됩니다. x값이 3면 y값은 4가 됩니다. 이처럼 x, y는 대입되는 값에 따라 값이 변한다고 해서 변수(Variable)라고 했고, 1, 2, 3, 4 등은 이미 정해져 있는 값이라고 해서 상수(Constant)라고 했습니다. 그리고 앞서 "02 자료형"에서 자료형을 배우면서 컴퓨터에서 데이터를 어떻게 메모리에 저장하는지를 살펴보았습니다. 그러므로 이제 변수에 대해 조금 더 깊이 알아볼 필요가 있습니다. 

```
int num = 1;
```
이 코드에 대한 컴퓨터의 동작은 다음과 같습니다. 
1. 자료형이 int이니 메모리에 주소 네 개를 확보해서 공간을 비워둡니다(어딘지는 컴퓨터만 알면 됩니다).
2. 그리고 십진수 1을 이진수로 변경해서 이 공간에 저장합니다.
3. 그리고 이 공간(주소)을 변수 num에 기억시킵니다.

그리고 이 변수를 다음과 같이 사용할 수 있습니다. 
```
System.out.println(num);
```
이 코드에 대한 컴퓨터의 동작은 다음과 같습니다. 
1. num 변수의 값은 어디에 있더라(메모리 어디에 적어두었는지 찾아옵니다).
2. 찾아낸 메모리의 시작 위치로 찾아갑니다.
3. num 변수는 int형이니까 4바이트를 읽습니다.
4. 그리고 int형이니까 십진수로 바꿔서 숫자로 알려줍니다. (만약 char 형이면 유니코드표를 보고 디코딩해서 문자로 알려줍니다.)

이렇게 되는 겁니다. 즉, 변수는 메모리 저장 공간을 기억하는 용도로 사용되는 겁니다. 

![1-35_variable_memory](https://github.com/user-attachments/assets/e8dc491a-5577-49ea-bb24-6152ee658506)

우리가 핸드폰의 연락처 앱에 친구 이름을 입력하면 폰의 메모리 어디에 적혀 있을지 모르지만 친구의 전화번호를 찾아노는 것과 같습니다.

### 1-2. 변수명을 짓는 방법
이런 변수명을 만들 때도 약간의 규칙은 있습니다. 다음은 변수 설정시 제약사항 입니다.
- 변수의 이름은 숫자로 시작할 수 없습니다.
- '$'와 '_'이외의 다른 특수문자는 변수의 이름에 사용할 수 없습니다.
- 키워드는 변수의 이름으로 사용할 수 없습니다.
  - 키워드는 자바의 문법을 구성하는 public, class, int double 같은 단어들을 말합니다.

다음은 변수 설정시 권장 사항입니다. 
- 소문자로 시작합니다.
  - 이렇게 하면 클래스의 이름이 대문자로 시작하는 것과 구별됩니다.
- 변수에서 사용되는 데이터를 유추할 수 있는 이름으로 만들어줍니다.
  - 여러 단어를 카멜 표기법을 이용하여 만들기도 합니다. (예: camelCase)
 
권장 사항은 수많은 선배 개발자의 노하우 입니다. 권장 사항을 지키면 코드 가독성이 좋아집니다.  

## 2. 상수 
선행 학습에서 '상수는 변하지 않는 값이다.'라고 가볍게 배우고 사용했습니다. 자바에서는 이런 상수에 두 가지 종류가 있습니다. 리터럴 상수와 final 상수입니다. 
### 2-1. 리터럴 
리터럴(literal)이란 문자 뜻 그대로, '문자 그대로의 값' 입니다. 1이라는 아라비아 숫자(글자)를 보면서 숫자 1의 개념을 생각할 수 있게 하는 문자 그대로의 값, A를 보면서 누구나 알파벳의 첫 글자라고 생각할 문자 그대로의 값을 말합니다. 이렇게 리터럴이란 문자 자체에 의미가 있어 누구나가 공통으로 그 의미를 알고 의미를 변경할 수 없습니다. 우리가 지금까지 변수에 대입하던 모든 숫자, 문자, 논리값(true, false)들이 리터럴 입니다. 

리터럴은 프로그램이 시작할 때 특정 메모리 공간인 상수 풀(Constant Pool)에 자동으로 로딩됩니다. 그리고 우리가 변수에 값을 대입할 때, 예를 들어 `int num = 1;` 이런 문장을 사용하면 상수 풀에서 1을 복사해서 num 변수에 대입해주는 겁니다. (한마디로 변하지 않는 값 또는 데이터를 말합니다)

### 2-2. final 상수
상수를 프로그래머가 임의로 만들 수도 있습니다. 자바에서는 final 키워드를 사용하여 상수를 만듭니다. 
```
final double = PI = 3.14;
final int MAX_SIZE = 100;
```
final 상수 이름은 대문자를 이용해서 만듭니다. 그러면 대소문자를 이용한 카멜 표기법을 사용할 수 없기 때문에 단어 단위를 구분해서 읽기 쉽게 언더바(_)를 이용해 단어를 구분해줍니다. 
- 모두 대문자라 첫 글자가 소문자인 변수의 이름과 구분됩니다.
- 모두 대문자라 단어의 첫 글자만 대문자인 클래스의 이름과 구분됩니다.

final 상수는 변수처럼 값을 대입하여 처음 값을 정하게 되지만 상수의 성격상 이후에는 다른 값을 대입받아 바꿀 수 없습니다. '이 값이 최종이다!'라는 의미로 final을 붙여놓은 겁니다. 그러므로 처음에 final 상수를 만들 때 값을 지정하지 않았다면 아직 최종 값이 있는게 아니므로 한 번은 넣어 줄 수가 있습니다. 

![1-36_final_constant_example](https://github.com/user-attachments/assets/29ca6c72-4b12-4546-8301-c2335f27bbd8)

## 3. 자료형의 형변환
지금까지 우리가 공부한 모든 내용이 메모리와 연관된 내용이었습니다. 이제부터 살펴볼 자료형의 형변환은 CPU와 관련된 내용입니다. 

### 3-1. 상수값 대입 시 형변환
아래와 같은 코드를 보면 생각나는 것이 많을 것 같습니다. 
```
byte num1 = 1;
short num2 = 1;
int num3 = 1;
long num4 = 1;
```

값 1은 리터럴 상수입니다. 프로그램이 시작될 때 메모리의 상수 풀에 로드되어 변수에 댑입이 될 때 복사가 되어서 사용된다고 했습니다. 여기서 메모리에 있다는 것은 자료형의 형태를 가지고 메모리의 공간을 사용하고 있다는 이야기입니다. 그러면 이 값들의 자료형은 무엇일까요? 정수형 리터럴 상수는 int형으로 처리하기로 약속되어 있습니다. 
```
double num5 = 1.0;
```
그리고 실수형 리터럴 상수는 double형으로 처리됩니다. 역시 규칙입니다. 기본 자료형 중에 정수와 실수는 문자나 논리형과는 달리 그 안에 종류가 여럿이라 기본형을 약속으로 정하고 사용합니다. 

자 이러면 또 고민이 생깁니다. 아래의 예제를 보겠습니다. 이 예제는 실행 결과를 출력하지 않습니다. Intelli J에 코드를 입력하고 에러가 발생하는지 여부만 확인하면 됩니다. 

![1-37_chagedata_example1](https://github.com/user-attachments/assets/2494b15d-71e9-4763-b1f0-c331bb21bb60)

"1번"에서 int형 리터럴 상수 1을 int형 변수 num2에 대입하니 아주 자연스럽습니다. 그런데 "2번"에서는 int형 상수 1을 byte 타입 변수 num2에 대입하고 있습니다. 4바이트 크기를 1바이트 크기의 공간에, 현실이라면 구겨넣어야 하는 것 입니다. 다행히도 자바 컴파일러는 리터럴 상수의 값을 알고 있으므로 앞부분을 잘라서 넣어줍니다(자동 형변환이라고 합니다. 지금은 큰 쪽에서 작은 쪽으로 형변환이 일어났습니다. int &rarr; byte). 

![1-38_chage_data_type_structure](https://github.com/user-attachments/assets/cade81fb-1e86-464e-8482-9b6aac821f10)

그런데 "3번"처럼 상수가 변수에 저장할 수 있는 범위의 값보다 큰 값이면 컴퓨터가 도와줄래야 도와줄 수가 없습니다. 앞부분을 자르자니 원래 값이 훼손되기 때문입니다. 그러므로 프로그래머가 고칠수 있게 에러를 냅니다. 

"4번"처럼 변수이면 타입만 비교하고 바로 에러 처리를 합니다. 변수에 혹시라도 작은 값이 있을 수도 있지만 큰 값이 들어올 수도 있으므로 컴파일러는 모험을 하지 않습니다. 역시 프로그래머가 고칠 수 있게 에러를 냅니다. 

"5번"은 프로그래머가 자기가 책임지겠다고 명시적으로 표시한 겁니다. 변수 안의 값을 알고 있으니 줄여도 된다고 명시적으로 표시해준 겁니다. 이럴 경우에는 에러를 내지 않고 대입해줍니다. 

다음은 형변환을 말하는 다양한 표현입니다. 

| 주최 | 용어 1 | 용어 2 |
|:---|:---|:---|
| 컴파일러(가 자동으로)| 자동 형변환 | 묵시적(암시적) 형변환 |
| 프로그래머(가 직접) | 강제 형변환 | 명시적 형변환 |

자동 형변환 방향은 다음 그럼과 같습니다. 

![1-39_change_datatype_structure](https://github.com/user-attachments/assets/f2c0acaa-3fad-4640-957b-3de8d34248cf)

이렇게 산술 연산에서 자동 형변환은 자료형 크기가 큰 쪽으로 일어나거나, 정수형에서 실수형으로 일어납니다. 컴파일러가 책임지지 않아도 되는 방향입니다(리터럴 1을 byte형 변수에 대입할 때 자동 형변환이 큰 쪽에서 작은 쪽으로 이뤄지는 것도 보았습니다. 역시 책임지지 않아도 되는 선까지만 동작합니다).

변수에 값을 대입 시 발생하는 형변환 예제를 또 하나 살펴보겠습니다(해당 경우도 Intelli J에 코드를 입력하고 에러가 발생하는지 여부만 확인하면 됩니다). 

![1-40_cahge_datatype_example2](https://github.com/user-attachments/assets/1fd47fc6-96d9-4646-a7b5-7def4fe177ed)

int형에서 최대로 표현할 수 있는 값은 2,147,483,647 입니다. 그래서 "1번" 대입은 정상적으로 이루어집니다. 

그런데 "2번"에서는 에러가 납니다. "아, 변수의 타입이 int라서 큰 값을 못 받는구나"하고 "3번"처럼 long형으로 바꾸어봅니다. 그렇지만 그래도 에러가 납니다. 2147483648을 인식하는 것 자체에서 문제가 있는 겁니다. 2147483648을 int형이라고 자바 컴파일러가 인식했기 때문에 쓸 수 없는 겁니다. 그래서 "4번"처럼 숫자 뒤에 L을 붙여서 "이 숫자는 long형으로 형변환한 거야"하고 알려주어야 합니다. 이렇게 입력한 "4번"에서는 에러가 나지 않습니다. 

"5번"도 에러가 납니다. 자바에서 사용하는 실수는 기본으로 double형이라고 했습니다. 그래서 1.0은 double형입니다. 여기서 "정수 때처럼 알아서 줄여주면 안돼?"라고 생각할 수 있지만 실수는 계산식에 의해서 만들어지는 근사치이므로 안 됩니다. 앞뒤 바이트를 줄이고 늘려서 만들 수 없는 값이기 때문입니다. 그래서 "6번"처럼 이 값은 float형이라고 형변환해서 알려주어야 합니다. 

"7번"에서는 int형의 상수 30이 double형의 상수 30.0으로 형변환된 후 가장 근사치 값을 계산하여 double형의 변수에 대입해줍니다. 

### 3-2. 연산 시 형변환 
형변환이 일어나는 곳이 또 있습니다. 산술 연산을 할 때 입니다. 연산은 CPU가 담당합니다. CPU에는 기본 자료형 수를 계산하는 연산 장치가 있는데, 이 장치가 다음과 같이 계산을 합니다. 단순하게 만들어져 있습니다.

| 입력1 | 입력2 | 입력3 |
|:---|:---|:---|
| int | int | int |
| long | long | long |
| float | float | float |
| double | double | double |

그러므로 이 외에는 다 형변환해서 넣어줘야 합니다. 

입력 1과 입력 2에 크기가 다른 자료형이 입력되면 어떻게 될까요? 큰 쪽에 맞춰서 먼저 형변환을 한 후 계산을 하게 됩니다. 예를 들어 byte, short는 일단 다 작으니 int로 형변환 후 계산을 하게 됩니다.

다음 예제를 만들어 에러를 확인해보겠습니다(실행하면 에러가 발생하는 예제입니다).

![1-41_change_datatype_example3](https://github.com/user-attachments/assets/4e9fdeca-6215-4777-a7df-1ee796e58435)

"1번" num11 + num12는 연산을 하려면 먼저 각각 int로 형변환된 후 더하기 연산을 하게 됩니다. 결과 역시 int형이기 때문에 byte 타입 변수 result1에 대입하지 못하고 에러가 발생합니다.

"2번" num21 + num22는 연산을 하기 위해 먼저 각각 int로 형변환된 후 더하기 연산을 하게 됩니다. 결과 역시 int형이기 때문에 short 타입 변수 result21에 대입하지 못하고 에러가 발생합니다. 

"3번" num21 + num22는 연산을 하기 위해 먼저 각각 int로 형변환 후 더하기 연산을 하게 됩니다. 그 결과 강제 형변환하여 short 타입으로 만들었습니다. 그 후 short 타입 변수인 result22에 대입하기 때문에 에러가 발생하지 않습니다. 

또 다음 예제를 만들어 자동으로 일어나는 형변환을 생각해봅시다(실행하면 에러가 발생하는 예제입니다).

![1-42_change_datatype_example4](https://github.com/user-attachments/assets/7b2765d3-f5ff-4487-95ab-418bf2a83180)

"1번" 'int형 변수의 값 + int형 변수의 값'이므로 계산 후 나온 int형 결과를 int형 변수 result3에 대입할 수 있습니다. 

"2번" 'long형 변수의 값 + long형 변수의 값'이므로 앞 쪽의 int형 변수를 long형으로 형변환 후 계산을 합니다. 계산 후 나온 long형 결과를 long형 변수 result4에 대입합니다. 

"3번" 'int형 변수의 값 + long형 변수의 값'이므로 앞쪽의 int형 변수를 long형으로 형변환 후 계산을 합니다. 계산 후 나온 long형 결과를 long형 변수 result5에 대입합니다.

"4번" float형의 상수임을 알려주기 위해 상수 뒤에 f접미사를 붙여주었습니다. "5번" 'float형 변수의 값 + float형 변수의 값'이므로 계산 후 나온 float형 결과를 float형 변수 result6에 대입합니다. 

"6번" 'double형 변수의 값 + double형 변수의 값'이므로 계산후 나온 double형 결과를 double형 변수 result7에 대입합니다.

"7번" 'float형 변수의 값 + double형 변수의 값'이므로 앞쪽의 float형 변수를 doulbe형으로 형변환 후 계산을 합니다. 계산 후 나온 double형 결과를 double형 변수 result8에 대입합니다. 

여기까지 산술 연산에서 발생하는 자동 형변환에 대해서 알아보았습니다. 

## 핵심 요약
- 변수는 메모리 공간을 기억하는 용도로 사용됩니다.
- 자바의 상수에는 리터럴 상수와 final 상수가 있습니다.
- 자바 컴파일러는 정수형 리터럴 상수를 int형으로 처리합니다.
- 자바 컴파일러는 실수형 리터럴 상수를 double형으로 처리합니다.
- 변수에 데이터를 대입할 때와 데이터끼리의 산술 연산을 할 때 형변환이 일어납니다.
