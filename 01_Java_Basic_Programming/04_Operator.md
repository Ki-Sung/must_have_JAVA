# 04 연산자 
- 흔히 연산이라고 하면 수학 시간에 배운 사칙연산을 떠올리겠지만, 프로그래밍에서 사용하는 연산은 그외에도 다양한 종류가 있습니다. 우리가 흔히 생각할 수 있는 산술연산 외에도 대입 연산, 비교 연산, 증감 연산, 논리 연산 등이 있습니다. 자바에서 다루는 연산을 알아보겠습니다.

## 1. 산술 연산자
자바에서 사칙연산 기능을 하는 연산자는 다음과 같습니다. 

| 연산자 | 설명 | 사용 예 | 결과 |
|:---|:---|:---|:---|
| + | 더하기 | 5 + 2 | 7 |
| - | 빼기 | 5 - 2 | 3 |
| * | 곱하기 | 5 * 2 | 10 |
| / | 나누기의 몫 | 5 / 2 | 2 |
| % | 나누기의 나머지 | 5 % 2 | 1 |

이미 선행 학습에서 다 사용해본 연산자입니다. 그런데 왜 수학에서와 달리 나누기 결과로 몫만 나올까요? 힌트는 앞 장에서 배운 자료형의 형변환에 있습니다. CPU가 계산을 할 때 두 정수를 입력받아 정수로 결과를 반환하는 구조로 만들어져 있기 때문입니다. 

간단한 예제를 만들어 확인해봅시다. 

![1-43_operator_exmaple_01](https://github.com/user-attachments/assets/8a21ca3f-6546-4df4-83b7-799cd6382508)
![1-44_operator_example_01_result](https://github.com/user-attachments/assets/9e317138-1201-492e-8d55-fc000c941205)

"1번"은 나누기의 몫 연산을 수행합니다. 7에서 3을 나눈 결과 2가 출력되었습니다. "2번"은 나누기의 나머지 연산입니다. 7에서 3을 나누기의 나머지 연산한 결과는 1 입니다.

## 2. 대입 연산자와 복합 대입 연산자 
대입 연산자는 오른쪽에 있는 연산식의 결과를 왼쪽에 있는 변수에 저장합니다. 이미 우리가 자연스럽게 사용하고 있는 연산자입니다. 
```
int num = 100;
int myScore = 50 + 20;
```
위 코드에서 등호 "="가 대입 연산자 입니다. 코드에서 보듯이 상수를 바로 대입할 수도 있고, 연산 결과를 대입할 수도 있습니다. 이때 자료형이 다르면 형변환이 일어납니다(연산자에 의해 연산을 하기 때문에 형변환도 일어나는 겁니다).

대입 연산자에는 단순한 대입인 등호 "=" 외에 다음과 같은 복합 대입 연산자도 있습니다. 

| 연산자 | 설명(다른 방법) |
|:---|:---|
| a += b | a = a + b |
| a -= b | a = a - b |
| a *= b | a = a * b |
| a /= b | a = a / b |
| a %= b | a = a % b |

복합 대입 연산자를 쓰는 사람들이 말하는 장점은 코드가 간결해진다는 겁니다. 하지만 처음 접하시는 분들은 햇갈리실 수도 있습니다, 코드를 보고 한번 더 머리속으로 생각해야 하거든요.

그렇다면 이 복합 대입 연산자는 왜 있을까요? 다음 에제에 답이 있습니다. 

![1-45_operator_example_02](https://github.com/user-attachments/assets/51efa602-4a2e-4a4a-9778-0768fb09c16c)
![1-46_operator_example_02_result](https://github.com/user-attachments/assets/79532c4b-9d69-429d-bb85-96dd6ce427f3)

"1번"에서는 형변환 없이 연산이 수행됩니다. 반면에 "2번"에서는 num값을 long형으로 자동 형변환 후에 num과 77L을 더하게 됩니다. 그리고 계산을 short 타입으로 형변환해야 대입할 수 있습니다. 

## 3. 부호 연산자와 증감 연산자 
부호 연산자는 기본 자료형의 숫자 부호를 나타낼 때 사용하고, 증감 연산자는 변수의 값을 1 증가시키거나 1 감소시킬 때 사용합니다. 
| 연산자 | 사용 예 | 설명 |
|:---|:---|:---|
| + | +x | 부호 유지(의미 없는 연산) |
| - | -x | 부호 반전 |
| ++ | ++x | 다른 연산 전 x값을 증가시킴 |
| ++ | x++ | 다른 연산 후 x값을 증가시킴 |
| -- | --x | 다른 연산 전 x값을 감소시킴 |
| -- | x-- | 다른 연산 후 x값을 감소시킴 |

그런데 +, -도 연산자냐 할 것 같아 예제를 준비했습니다. 

![1-47_operator_example_03](https://github.com/user-attachments/assets/9081f1b8-5978-493d-a18b-fac79827c8b7)
![1-47_operator_example_03_result](https://github.com/user-attachments/assets/101cd6d8-38f4-4038-9bd3-731652442290)

"1번"과 "2번"의 실행 결과만 놓고 보면 이게 과연 연산자인가 할 수 있습니다. 하지만 "3번"에서 보면 + 연산자에 의해 연산이 이루어 집니다. 연산이 이루어지려면 형변환이 일어나야 합니다. 현재 short이니까 int로 말이죠. 이렇게 + 연산자에 의해 연산이 이루어지고 int로 형변환이 되었기 때문에 다시 short로 강제 형변환을 해주어야 변수에 값을 대입할 수 있습니다. +, -도 연산자임을 이렇게 확인해볼 수 있습니다. 

증감 연산자도 예제를 만들어 확인해보겠습니다. 

![1-48_operator_example_04](https://github.com/user-attachments/assets/965b90fa-e536-4317-bb4b-c7d4d6b4e8b4)
![1-49_operator_example_04_result](https://github.com/user-attachments/assets/ceeb0da5-31c9-453f-960c-7e7e45b0c91d)

"1번" 변수를 선언하고 값을 대입합니다. "2번"을 먼저 변수의 값을 증가시키고 그다음을 출력합니다. "3번" 출력된 num 변수의 값이 증가되어 있음을 확인할 수 있습니다. 

"4번" 먼저 num 변수의 값을 출력하고, 그 후에 값을 증가시킵니다. "5번" num 변수의 값을 확인해보면 값이 증가되어 있습니다. 

이런 증감 연산자는 다른 연산자와 같이 사용하게 되면 의도치 않게 생각이 깊어집니다. 

```
int result = num++;
```

num 값이 증가하고 대입이 되는 것인지, 대입이 된 후에 나중에 증가되는지 고민을 하게 됩니다. 복잡하고 크리티컬한 업무에서 이런 고민으로 인한 실수가 발생하면 안 됩니다. 

좋은 코드는 간결한 코드입니다. 코드 자체를 축약해서 짧게 만든다는 이야기가 아닙니다. 들여쓰기 등이 잘 맞아 있는 물리적인 깔끔함에, 고민 없이 바로 읽을 수 있는 생각을 간결하게 해주는 코드입니다.

그래서 아래처럼 반복문에서 단독으로 사용하는 것이 좋습니다.

```
for (int i = 0; i < 10; i++)
{
    ...
}
```

```
int i = 0;
while (i > 10)
{
    ...
    i++;
}
```

## 4. 비교 연산자(관계 연산자)
비교 연산자는 두 피연산자를 비교해 결괏값으로 논리 값인 true나 false를 반환해줍니다. 관계 연산자라고도 합니다. 
```
int x = 2;
int y = 1;
```
위와 같이 x와 y가 있을 때 연산 결과를 확인해보겠습니다. 

| 연산자 | 사용 예 | 설명 | 결과 |
|:---|:---|:---|:---|
| == | x == y | x는 y와 같다 | false |
| != | x != y | x는 y와 같지 않다 | true |
| > | x > y | x는 y보다 크다 | true |
| >= | x >= y | x는 y보다 크거나 같다 | true |
| < | x < y | x는 y보다 작다 | false |
| <= | x <= y | x는 y보다 작거나 같다 | false |

코드를 작성할 때, 위와 같이 결론을 내고 결괏값이 들어와 있다고 생각을 해야합니다. 이렇게 하면 자연스럽게 컴퓨터의 연산 순서사 됩니다.

<img width="973" alt="1-50_operator_structure" src="https://github.com/user-attachments/assets/37cad3ee-1230-45c9-8c62-9728aff6d888">

위의 예를 보면 if문이 연산 결과를 만드는 것이 아니고 if문은 true, false만 확인하는 것이고, 비교 연산자가 true, false를 만드는 것입니다. 그래서 선행 학습 떄 while문에서 다음과 같이 코드를 사용할 수 있었던 겁니다.

```
while (true)
{
    ...
}
```

다음은 비교 연산자를 사용하는 예제입니다. 

![1-51_compare_oprator_example](https://github.com/user-attachments/assets/d72c99cb-3e53-4630-a439-f3fd3ba7c4b7)
![1-52_compare_oprator_example_result](https://github.com/user-attachments/assets/db542497-6247-4e4e-909e-4209f91cb93c)

아래 두 코드를 보면 1.0과 1은 실수와 정수인데, 그 결과가 놀랍게도 true와 false 입니다. 실수형으로 자동 형변환이 이뤄진 다음 비교 연산을 수행했기 때문입니다. 이처럼 비교 연산 시에도 형변환이 일어난다는 점 참고하시면 좋을 것 같아요.

## 5. 논리 연산자
논리 연산자는 예전 수학 시간에 배운 명제(논리적으로 뜻이 분명한 문장)를 다룹니다. 

- 두 명제가 모두 참이면 논리곱은 참입니다.
- 두 명제 중 하나라도 참이면 논리합은 참입니다.
- 참의 부정은 거짓, 거싲의 부정은 참입니다.

이러면 논리 연산을 프로그래밍 언어로 표현한 연산자가 논리 연산자입니다.

| 연산자 | 기능 |
|:---|:---|
| && (논리곱, And) | 두 항이 모두 참이면 결괏값이 참입니다. 그렇지 않으면 모두 거짓입니다. |
| ll (논리합, Or) | 두 항 중 하나의 항이라도 참이면 결괏값은 참입니다. 두 항이 모두 거짓이면 결괏값은 거짓입니다. |
| ! (부정, Not) | 값이 참인 경우는 거짓으로 바꿉니다. 값이 거짓인 경우는 참으로 바꿉니다. |

true, false 논리 연산 진리표를 살펴봅시다. 

| A | B | A && B | A ll B | !A |
|:---|:---|:---|:---|:---|
| true | true | true | true | false | 
| true | false | false | true | false | 
| false | true | false | true | true | 
| false | false | false | false | true | 

다음은 논리 연산자를 사용하는 예제입니다. 

![1-53_compare_opreator_exmaple2](https://github.com/user-attachments/assets/7164a9b9-0dd6-4446-996f-e155f9d10d52)
![1-54_compare_opreator_exmaple2_result](https://github.com/user-attachments/assets/6c7edf7b-cf5a-4807-8cfb-3583dc6e0761)

"1번" num1의 값은 11로, 10 보다 작지 않으므로 조건절을 만족하지 않아 false 입니다. "2번" num2의 값은 22이므로 2의 배수입니다. 2의 배수이거나 3의 배수이면 되므로 결과는 true 입니다. 

### 5-1. 논리 연산자의 주의점
그런데 이 논리 연산자를 사용해야 할 때 주의할 점이 있습니다. 연산의 특성 중에 Short Circuit Evaluation(SCE)라는 것이 있습니다. 우리말로 하면 "최단 거리 평가" 정도로 볼 수 있는데, 보통 SCE 라고 부릅니다. 이는 연산의 효율 및 속도의 향상을 위해 불필요한 연산을 수행하지 않는 기능을 말합니다. 

예를 들어 논리곱에서 둘 다 참이어야 참이 되므로 앞쪽이 거짓이면 뒤쪽 계산을 수행하지 않습니다. 논리합에서 둘 중 하나라도 참이면 참이 되므로 앞쪽이 참이면 역시 뒤쪽 계산을 수행하지 않게 됩니다. 

다음 예제로 확인해보겠습니다. 

![1-55_logic_operator_example](https://github.com/user-attachments/assets/20e9bb0b-548a-4c47-a6d5-e66b02d7f2a2)
![1-56_logic_operator_example_result](https://github.com/user-attachments/assets/b4096323-6bcb-44e2-8405-1d52e17870b8)

"1번"에서 코드의 변화를 보겠습니다. 

![1-57_logic_operator_example_result_structure](https://github.com/user-attachments/assets/095ea327-89b4-4e55-aff1-f7818a19a46e)

이렇게 && 뒤쪽의 연산은 시작도 못해보고 result가 false가 결과로 대입됩니다. "2번"도 마찬가지 입니다. `||` 뒤쪽에 있는 y는 연산이 수행되지 않아 값이 증가하지 않았고, 초깃값 그대로 0입니다.

## 6. 조건 연산자 
조건 연산자는 주어진 조건식이 참인 경우와 거짓인 경우에 다른 결괏값을 나타내주는 연산자입니다. 

수식 표현법은 다음과 같습니다. 
```
조건식 ? 참일 때 실행: 거짓일 때 실행; 
```

사용 예를 코드로 표현해보겠습니다. 

![1-58_conditional_structure](https://github.com/user-attachments/assets/18efd251-3b35-42ba-9937-f79629d66a2a)

예제를 보시면 이해가 쉬울 것입니다.
![1-59_condition_example](https://github.com/user-attachments/assets/5766d435-bede-44be-97de-a8a9714eed71)
![1-60_condition_result](https://github.com/user-attachments/assets/de8c002b-efb4-493f-9610-f8b14fc20190)

1번 "num1 값이 num2 보다 크다" 이 명제의 결과는 거짓이기 때문에 거짓일 때 실행되는 부분에서 num2 값을 가져와 big 변수에 대입합니다. 

2번 "num1 값이 num2 값 보다 크다" 이 명제의 결과는 거짓이기 때문에 거짓일 때 실행되는 부분의 num2 - num1 연산을 수행하고 그 결과를 diff 변수에 대입합니다. 

조건 연산자는 이렇게 조건에 따른 항의 결과값 또는 연산이 수행된 결과를 반환하는 연산자입니다. 

- 참고: 선행 학습에서 사용했던 "if ~ else ~"와 같은 동작을 합니다. 차이점은 "if ~ else ~"는 제어문 중 조건문이고, 지금 사용한 것은 조건 연산자입니다.

## 7. 단항, 이항, 삼항 연산자
연산자를 항 개수로 구분할 수 있습니다. 자바는 단항, 이항, 삼항 연산자를 제공합니다. 

- 단항 연산자: `++x, y--`에서 ++, --는 하나의 피연산자만으로 이루어진 식으로 연산을 수행합니다. 이런 연산자를 단항 연산자라고 합니다.
- 이항 연산자: `x + y`에서 + 연산자는 피연산자를 두 개 가지고 식을 구성하기 때문에 이항 연산자라고 합니다.
- 삼항 연산자: 삼항 연산자는 항이 세 개 있어야 합니다. 우리가 앞서 배운 조건 연산자가 삼항 연산자입니다. 삼항  연산자는 다음과 같이 표현 합니다.
```
1항 ? 2항 : 3상;
```

## 8. 연산자 우선순위
이런 연산자들은 연산을 수행함에 있어 우선순위르 가집니다. 이 역시 우리가 수학 시간에 배웠던 내용과 거의 유사합니다. 아래의 표에 정리해보겠습니다. 

| 우선순위 | 종류 | 연산자 |
|:---|:---|:---|
| 1 |  | `.(점)`, `[](대괄호)`, `()(소괄호)` |
| 2 | 단항 | `++(증가)`, `--(감소)`, `!(부정)`, `+(부호)`, `-(부호)` |
| 3 | 산술 | `*(곱하기)`, `/(나누기)`, `%(나머지)` |
| 4 | 산술 | `+(더하기)`, `-(뺴기)` |
| 5 | 비교 | `<(작다)`, `<=(작거나 같다)`, `>(크다)`, `>=(크거나 같다)` |
| 6 | 관계 | `==(같다)`, `!=(같지 않다)` |
| 7 | 논리곱 | `&&(and)` |
| 8 | 논리합 | `ll(or)` |
| 9 | 조건 | `booleanExpression ? exp1 : exp2` |
| 10 | 대입 | `=` `+=` `*=` `/=` `%=` |

우리 코드의 많은 부분에서 괄호가 사용되었습니다. 연산자의 우선순위가 헷갈릴 땐 괄호를 사용하면 연산 순위의 의미가 확실해집니다. 소괄호는 표에서도 확인되듯 우선순위가 가장 높기 때문에 사용하면 먼저 연산을 해줍니다. 

다음은 연산 순위 중 헷갈릴 수 있는 예제입니다. 

![1-61_order_example](https://github.com/user-attachments/assets/5f27a8c3-ae5f-4067-81d7-2887966c4cbd)
![1-62_order_result](https://github.com/user-attachments/assets/b344ce7b-e86d-4320-863b-edfd4b70ca6e)

1번 `println()`에 내용을 입력하지 않고 그냥 사용하면 줄바꿈만 해줍니다. 

2번 `print()`은 줄을 바꾸지 않지만 아스키코드 표를 보고 줄바꿈 특수 문자를 출력하면 줄바꿈을을 할 수 있습니다. 
- 3번 'n': 작은 따옴표로 n을 감쌈 -> 문자형
- 4번 "n": 큰 따옴표로 n을 감쌈 -> 스트링 객체, 글자들

3번에서 num 변수에는 값이 이미 이진수로 들어가 있습니다. '\n'은 문자형 데이터이기 때문에 2바이트 크기를 가질 것이고 이진수로 변환, 즉 인코딩이 됩니다(자바에서 이 문자는 ASCII 코드 값으로 10으로 인코딩 됩니다). 그 결과 '이진수 + 이진수' 산술 연산이 일어납니다. 크기가 다르니 뒤쪽 값이 2바이트에서 4바이트로 형변환이 되고 그 후 산술 연산인 더하기가 실행됩니다. 산술 연산의 결과 15가 출력되고 줄바꿈하려는 의도와 달리 줄바꿈이 되지 않습니다.

4번에서 사용한 "\n"은 큰 따옴표로 감싸져 있습니다. 스트링(문자열) 객체라고 하는데, 쉽게 말하면 글자들입니다. 한 글자인데 뭔 글자들이라고 하겠지만, 글자들을 담을 수 있는 형태인데 여기선 한 글자만 담은 겁니다. 

char형에는 변수에 한 글자밖에 대입이 안되지만 String형에는 글자 길이에 제한이 없습니다. 여기서 한 글자만 넣은 것뿐입니다. 

기본 자료형일 때만 산술 연산을 할 수 있습니다. 기본 자료형이 아니라면 CPU가 다른 방법을 찾습니다. 그래서 양쪽의 내용을 합쳐서 출력해줍니다. 

꼭 기억해주세요. 산술 연산은 데이터가 기본 자료형일 때만 일어납니다. 4번은 '기본 자료형 + 스트링' 연산이므로 산술 연산이 일어나지 않습니다. 산술 연산이 아니니 에러를 내든지 다른 어떤 동작을 해야 합니다.다행히 `println()`안에 사용된 +연산자는 산술 연산이 아니면 그냥 합쳐서 출력하는 동작을 제공합니다. 4번에서 코드 변화를 살펴보겠습니다. 

![1-63_order_example_01_structure](https://github.com/user-attachments/assets/c5605a6a-4d04-43bd-8d6e-1512e4132ba3)

5번도 같은 절차로 동작하게 됩니다. 

6번에서 주석을 풀면 에러가 나는데, 이유는 다음과 같은 순서로 동작하기 때문입니다. 

![1-63_order_example_02_structure](https://github.com/user-attachments/assets/ec81bdcc-54f4-40c7-98e0-cfa22fafabde)

비교를 할 수 없고, 다른 동작도 정의되어 있지 않으므로 컴파일러는 에러를 냅니다. 에러의 내용은 다음과 같습니다.
"연산자 >=가 인수 유형이 String과 int에 대해 정의되지 않았음"

### 마무리 - 핵심 요약
1. 산술 연산자는 사칙연산 계산 기능을 하는 연산자 입니다.
2. 대입 연산자는 오른쪽에 있는 연산자의 결과를 왼쪽에 왼쪽에 있는 변수에 저장합니다.
3. 부호 연산자는 기본 자료형의 숫자 부호를 나타낼 때 사용하고, 증감 연산자는 변수의 값을 1 증가시키거나 1 감소시킬 때 사용합니다.
4. 비교 연산자는 두 피연산자를 비교해 결괏값으로 true나 false를 반환해줍니다.
5. 논리 연산자는 논리 연산을 프로그래밍 언어로 표현한 연산자입니다.
6. 조건 연산자는 주어진 조건식이 참인 경우와 거짓인 경우에 다른 결괏값을 나타내주는 연산자입니다.
7. 자바는 단항, 이항, 삼항 연산자를 제공합니다.
8. 연산자들은 연산을 수행함에 있어 우선순위를 가집니다.
