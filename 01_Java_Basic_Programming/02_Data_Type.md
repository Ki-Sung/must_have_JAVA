# 02 자료형 
- 프로그래밍을 이해하려면 하드웨어 동작 원리를 알아야할 필요가 있습니다. 하드웨어를 제어하는 코드의 묶음이 프로그래밍이기 때문입니다. 하드웨어의 동작 이해와 함꼐 자료형을 배워보겠습니다.
- 예제 코드는 "01_Java_Basic_Programming/code/src/Chap_01_Data_Type"에서 확인하실 수 있습니다.

## 1. 진수 계산법 
여기서는 자료형을 다룹니다. 사람이 10진수로 값을 입력해도 컴퓨터는 무조건 2진수로 변환해 저장합니다. 그래서 자료형을 다룰 때 진수 변환을 알면 편합니다. 깊고 어려운 내용을 다루기 보다 간단히 진수 계산법을 살펴보고 넘어갑시다.

### 1-1. 지수 계산
지수 계산하는 방법은 학창 시절에 배워서 다 아실 겁니다. 컴퓨터는 2진수를 기반으로 데이터를 관리하기 때문에, 복습하는 차원에서 아래의 표로 정리해보았습니다.

|지수 표현|풀이|10진수 정수값|
|:---|:---|:---|
| $2^0$ | = 1| = 1|
| $2^1$ | = 2| = 2|
| $2^2$ | = 2 x 2| = 4|
| $2^3$ | = 2 x 2 x 2| = 8|
| ... | ... | ... |
|$2^8$|   | = 256 |
| ... |   | ... |

모두 기억나셨죠? 이어서 10진수를 2진수로 바꾸는 방법을 살펴보겠습니다.

### 1-2. 10진수를 2진수로 바꾸기
10진수 11을 2진수로 바꾸려면 1번째 화살표 처럼 더 이상 나눌 수 없는 정숫값이 나머지로 나올 때까지 2로 계속 나누고 2번째 화살표 방향 순서로 배치해면 됩니다. 

![1-22_decimal_to_binary](https://github.com/Ki-Sung/must_have_JAVA/assets/80456601/54e5a5f7-17a0-49b6-9d4f-99600892eec7)

- 결론: 10진수 11 = 2진수 $1011_2$

### 1-3. 2진수를 10진수로 바꾸기
이번에는 2진수 1011을 10진수로 바꾸어 보겠습니다. 1번째 화살표 자리별로 지수 계산을 한 뒤 2번째 화살표 처럼 모든 숫자를 더합니다. 

![1-23_bianry_to_decimal](https://github.com/Ki-Sung/must_have_JAVA/assets/80456601/6065d1cb-e03b-4989-a50b-735f691e5dcb)

- 결론: 2진수 $1011_2$ = 10진수 11

이 정도 내용을 알고 계시면 이후 내용을 보는데 어려움이 없을 것 입니다. 

### 1-4. 계산기를 이용한 진수 변환
Mac OS에서 기본으로 제공하는 계산기를 이용하면 쉽게 진수별 값을 알 수 있습니다. 먼저 10 진수로 선택 후 11을 입력하면 가운데 2진수 표시가 뜹니다. 

![1-24_bianry_can](https://github.com/Ki-Sung/must_have_JAVA/assets/80456601/5482ee1b-e70a-4d39-97e1-053eda392a7c)

## 2. 컴퓨터에서 데이터 처리 방식 
프로그램은 미리 정해진 일을 순서대로 컴퓨터 하드웨어에 전기 신호를 보내서 컴퓨터 하드웨어를 동작시키고 데이터를 표현합니다. 컴퓨터 하드웨어에 신호를 보낼 때 전류를 약하게 보냈다가 강하게 보냈다가 하는 방법을 사용합니다. 이것을 기계어로 숫자 0과 1로 표현하게 되는데, 우리가 마침 알고 있는 이진수와 같은 형태입니다. 

컴퓨터에서 숫자 데이터를 표현하려면 전기 신호를 다음 이진수로 적어놓은 것처럼 보내야 합니다. 

|10진수 숫자|2진수 신호|
|:---|:---|
| 0 | 0 | 
| 11 | 1011 | 
| 255 | 1111 1111 | 

"1 프로그래밍 언어"에서 설명한 것 처럼 1바이트는 비트 8개를 모아놓은 것이고, 1바이트는 컴퓨터에서 정보를 처리하는 기본 단위입니다. 1바이트로 양수만 표현하면 0에서 255까지 표현할 수 있습니다. 1바이트에서 제일 큰 수는 1111 1111 이기 때문입니다. 

255보다 큰 256을 표현하고 싶습니다. 어떻게 해야할까요? 컴퓨터에서 정보를 처리하는 기본 단위가 바이트 이므로 1비트나 4비트만 추가할 수는 없습니다. 바이트 단위로 추가해야 합니다. 예를 들어 8인용 객실만 가진 호텔이 있습니다. 일행이 9명인 손님이 왔습니다. 이러면 방 두 개를 빌려줘야 하겠지요?

따라서 256을 표현하는데 9비트를 사용하지 않고 바이트를 하나 더 사용해 2바이트, 총 16비트를 사용하게 됩니다. 바이트 두 개를 합쳐 하나의 신호로 사용합니다. 256을 표현해 보내는 신호는 다음과 같습니다. 

|10진수 숫자|2진수 신호|
|:---|:---|
| 256 | 1 0000 0000 &larr; 잘못된 표현 | 
| 256 | 0001 0000 0000 &larr; 잘못된 표현 | 
| 255 | 0000 0001 0000 0000 &larr; 올바른 표현 | 

이런 신호로 전달된 데이터를 메모리에 저장할 때도 바이트 단위는 중요하게 사용됩니다. 바이트는 컴퓨터에서 데이터를 처리하는 기본 단위 이면서 메모리 위치를 표시하는 최소 단위 이기도 합니다. 실제로 메모리에는 1바이트 마다 주소가 매겨져 있습니다. 

![1-25_memory_adress](https://github.com/Ki-Sung/must_have_JAVA/assets/80456601/edb04662-99db-41f6-92dd-8c7bb95b2afa)

메모리는 8비트, 즉 1바이트씩 저장하는 구조라서 방마다 주소를 매겨 놓았습니다. 그러므로 8비트 보다 적게 보내도 방 하나를 차지합니다. 실제로도 바이트 단위로 전달받아 저장하게 됩니다. 따라서 숫자 256을 저장하려면 신호를 '0000 0001 0000 0000'으로 받아서 메모리 주소 2개를 사용해서 저장합니다. 

- **참고**: 32비트 CPU에서 처리할 수 있는 최대 메모리 크기
  - 표현할 수 있는 메모리 주소의 범위가 0 ~ $2^{32}$ - 1, 총 크기는 $2^{32}$(=4GB)입니다. 2진수로 표현하면 너무 길게 써야해서 16진수로 나타내면 메모리 주소는 00000000 부터 FFFFFFFF 까지 입니다.
  - 그래서 32비트 컴퓨터에서는 4GB 이상의 메모리를 사용할 수 없습니다. 물리적으로 존재해도 소프트웨어적으로 주소를 표시해줄 수 없기 때문입니다. 즉, 장치에서 1GB 메모리가 있을 때 4GB 메모리를 추가해서 물리적으로 5GB가 되더라도 4GB밖에 사용할 수 없습니다.
    ![1-26_sperate_memory](https://github.com/Ki-Sung/must_have_JAVA/assets/80456601/afec3c3f-7b58-490c-982e-cd135e878a2b)

## 3. 자바 기본 자료형
개인용 컴퓨터도 하드디스크가 테라바이트(Terabyte, TB) 시대 입니다. 그런데 메모리는 아직도 8GB, 16GB, 32GB, 정말 많으면 48GB 입니다. 하드디스크에 비해 메모리가 월등히 비쌉니다. 컴퓨터가 나온 초창기에도 사정은 비슷했습니다. 그래서 작고 비싼 메모리를 아껴 효율적으로 사용할 필요가 있었습니다. 효율적으로 데이터를 사용하고 메모리를 아껴 쓰려면 자료형을 잘 활용해야 합니다. 

자바에서 제공하는 기본 자료형은 크게 정수형, 문자형, 논리형, 실수형으로 나눌 수 있습니다. 각각에 대해 알아보겠습니다. 

### 3-1. 정수형 
정수 자료형은 숫자를 담는 자료형입니다. 예를 들어 국어, 영어, 수학 점수를 저장하는 데는 큰 저장 공간이 필요하지 않습니다. 100점 만점이기 때문에 1바이트면 충분합니다. 1바이트로 255까지 처리할 수 있으니까요. 점수를 저장하는데 4바이트를 사용한다면 3바이트를 낭바하게 됩니다. 그래서 상황에 따라 사용하는 데이터의 최대 크기를 정할 필요가 생겼습니다. 

그런데 A 데이터는 메모리 한 칸 사용, B 데이터는 메모리 두 칸 사용 이렇게 표현하면 말하는 사람이나 듣는 사람이나 좀 불편합니다. 그래서 단위에 `byte`, `short`, `int`, `long`이라는 이름을 붙입니다.

| 용도 | 자료형 이름 | 값의 크기 | 자바에서 값의 범위 |
|:---|:---|:---|:---|
| 1바이트 사용할 때 | byte | $2^8$ | $-2^7$(-128) ~ $2^7$-1(127) |
| 2바이트 사용할 때 | short | $2^{16}$ | $-2^{15}$(-32,768) ~ $2^{15}$-1(32,767) |
| 3바이트 사용할 때 | int | $2^{32}$ | $-2^{31}$(-2,147,483,648) ~ $2^{31}$-1(2,147,483,647) |
| 8바이트 사용할 때 | long | $2^{64}$ | $-2^{63}$(-9,223,372,036,854,775,808) ~ $2^{63}$-1(9,223,372,036,854,775,807) |

앞에서 말한 것처럼 1바이트로는 $2^8$, 총 256가지를 구분할 수 있습니다. 자 이제 숫자 데이터를 표현할 때를 정리해보겠습니다.

| 구분 | 값의 범위 | 경우의 수 |
|:---|:---|:---|
| 양수만 표현 | 1 ~ 256 | 256가지 | 
| 0 포함 양수 표현 | 0, 1 ~ 256 | 256가지 | 
| 음수까지 표현 | -128 ~ -1, 0, 1 ~ 127 | 256가지 양수를 반으로 나누어 음수에 배치, 그리고 양수쪽에서 하나를 빼서 0을 포함 |

자바에서는 '음수까지 표현'한 방식을 자료형 크기로 사용합니다. 그래서 자바에서는 데이터를 표현할 때 "이 데이터는 값의 범위가 -128 부터 127까지 사이에서 저장할 수 있겠군. 그러면 메모리 주소 한 칸을 사용하면 충분하겠어. 이런 상황이면 이 데이터는 byte 자료형으로 사용하면 되겠어." 이렇게 표현하는 겁니다. 나머지 자료형도 같은 방식으로 이해하고 똑같이 해석하면 됩니다. 

이것을 변수에 적용하려면 아래와 같습니다. 다 같은 십진수 1을 변수에 대입하지만 메모리에 값이 저장될 때는 다르게 동작합니다.

![1-27_int_datatype](https://github.com/Ki-Sung/must_have_JAVA/assets/80456601/84827d27-9fa9-4b30-ae53-aaaba728f947)

num1 변수는 byte 자료형으로 만들었습니다. 이제 이 변수와 이 변수의 자료형을 보면서 우리는 '메모리 주소 하나를 사용하여 데이터를 저장할 수 있겠구나'하고 순간적으로 생각하게 될 것입니다. 이게 서로의 약속이니까요. 그리고 십진수 1을 대입합니다. 그러면 컴퓨터는 십진수 1을 이진수 0000 0001로 변환하여 메모리에 저장하게 됩니다. 

나중에 num1을 사용하면 컴퓨터는 "아 num1은 byte 자료형이니까 저장된 위치에서 메모리 주소 한 칸만 읽어서 꺼내주면 되겠구나" 하면서 값을 읽어 알려줍니다. 이때 이진수로 알려주면 우리가 당황하니까 십진수로 바꾸어서 알려줍니다.

나머지 변수들도 마찬가지 방식으로 작동합니다. 

그러면 long 자로형에다 1을 저장하는 건 너무 낭비가 아니냐 할 수도 있습니다. 변수를 선언할 때는 1을 대입했지만 나중에 큰 값을 다시 대입할 수도 있습니다. 지금 당장 저장하는 값이 작다고 하더라도 앞으로 저장할 값의 범위에 따라 변수 자료형을 지정해주면 됩니다.\
(프로그래밍에서 자료형을 정할 때는 '메모리에서 데이터 저장 효울성'을 따져야 한다는 것을 명심해야 합니다.)

### 3-2. 문자형

자 이제는 문자 데이터에 대해 알아보겠습니다. 문자 자료형은 다음과 같습니다. 

| 자료형 이름 | 자료형 크기 |
|:---|:---|
| char | 2바이트 |

자료형과 이름을 정해서 변수를 선언하고 값을 대입해줍니다. 코드를 표현하면 아래와 같습니다.
```
char ch1 = 'A';
```
  - 문자 자료형 변수에는 한 글자만 대입할 수 있습니다.
  - 자바에서는 문자를 표현할 때 작음따옴표를 사용합니다. 

ch1 이라는 변수는 자료형이 char이니까 규칙대로 2바이트 메모리 공간에 신호를 저장하면 되겠습니다. 그런데 문자 'A'를 0과 1 두 가지 신호로 어떻게 표현할까요? 자바에서는 문자를 표현하는 신호는 유니코드(Unicode)표를 보고 참조합니다. 

```
* 참고 - 유니코드와 아스키코드
1바이트 문자를 저장하던 프로그래밍 언어에서는 아스키코드(ASCII) 코드표를 사용했습니다. 표현하는 아스키코드표에는 총 128개 영문자, 숫자, 특수 문자가
약속되어 있습니다. 컴퓨터가 전 세계로 보급되고 프로그래밍이 발전하면서 영문자 뿐만 아니라 다양한 언어를 표현할 필요가 대두되었습니다.
이런 요구에 부합하는 문 코드 규약인 유니코드(Unicode)1.0 버전이 1991년에 공개되었습니다. 자바는 유니코드표를 참조해 유니코드의 0번 플레인까지는
1개 char 타입(2바이트)으로 표현되고 나머지 1~16번 플레인은 2개의 char 타입을 묶어(4바이트) 1개의 문자를 표현합니다.
참고로 유니코드의 1바이트 앞 부분(처음 7바이트)은 아스키코드 값과 똑같습니다.
한글 유니코드는 해당 URL 참조: https://www.unicode.org/charts/PDF/UAC00.pdf
```
유니코드 1바이트 앞 부분(처음 7바이트)과 같은 아스키코드 값을 확인해봅시다. 아스키코드표는 다음과 같이 1바이트의 양의 정수 부분에 영문자, 숫자, 특수 문자의 신호를 정해놓습니다. 

<table>
  <tr>
    <td>
      <table border="1">
        <tr>
          <th> 10진수 </th>
          <th> 16진수 </th>
          <th> 8진수 </th>
          <th> 2진수 </th>
          <th> ASCII </th>
        </tr>
        <tr>
          <td> 65 </td>
          <td> 0x41 </td>
          <td> 101 </td>
          <td> 1000001 </td>
          <td> A </td>
        </tr>
        <tr>
          <td> 66 </td>
          <td> 0x42 </td>
          <td> 102 </td>
          <td> 1000010 </td>
          <td> B </td>
        </tr>
        <tr>
          <td> 67 </td>
          <td> 0x43 </td>
          <td> 103 </td>
          <td> 1000011 </td>
          <td> C </td>
        </tr>
        <tr>
          <td> 68 </td>
          <td> 0x44 </td>
          <td> 104 </td>
          <td> 1000100 </td>
          <td> D </td>
        </tr>
        <tr>
          <td> 69 </td>
          <td> 0x45 </td>
          <td> 105 </td>
          <td> 1000101 </td>
          <td> E </td>
        </tr>
        <tr>
          <td> 70 </td>
          <td> 0x46 </td>
          <td> 106 </td>
          <td> 1000110 </td>
          <td> F </td>
        </tr>
        <tr>
          <td> 71 </td>
          <td> 0x47 </td>
          <td> 107 </td>
          <td> 1000111 </td>
          <td> G </td>
        </tr>
        <tr>
          <td> 72 </td>
          <td> 0x48 </td>
          <td> 110 </td>
          <td> 1001000 </td>
          <td> H </td>
        </tr>
        <tr>
          <td> 73 </td>
          <td> 0x49 </td>
          <td> 111 </td>
          <td> 1001001 </td>
          <td> I </td>
        </tr>
        <tr>
          <td> 74 </td>
          <td> 0x4A </td>
          <td> 112 </td>
          <td> 1001010 </td>
          <td> J </td>
        </tr>
        <tr>
          <td> 75 </td>
          <td> 0x4B </td>
          <td> 113 </td>
          <td> 1001011 </td>
          <td> K </td>
        </tr>
        <tr>
          <td> 76 </td>
          <td> 0x4C </td>
          <td> 114 </td>
          <td> 1001100 </td>
          <td> L </td>
        </tr>
        <tr>
          <td> 77 </td>
          <td> 0x4D </td>
          <td> 115 </td>
          <td> 1001101 </td>
          <td> M </td>
        </tr>
      </table>
    </td>
    <td>
      <table border="1">
        <tr>
          <th>10진수</th>
          <th>16진수</th>
          <th>8진수</th>
          <th>2진수</th>
          <th>ASCII</th>
        </tr>
        <tr>
          <td> 78 </td>
          <td> 0x4E </td>
          <td> 116 </td>
          <td> 1001110 </td>
          <td> N </td>
        </tr>
        <tr>
          <td> 79 </td>
          <td> 0x4F </td>
          <td> 117 </td>
          <td> 1001111 </td>
          <td> O </td>
        </tr>
        <tr>
          <td> 80 </td>
          <td> 0x50 </td>
          <td> 120 </td>
          <td> 1010000 </td>
          <td> P </td>
        </tr>
        <tr>
          <td> 81 </td>
          <td> 0x51 </td>
          <td> 121 </td>
          <td> 1010001 </td>
          <td> Q </td>
        </tr>
        <tr>
          <td> 82 </td>
          <td> 0x52 </td>
          <td> 122 </td>
          <td> 1010010 </td>
          <td> R </td>
        </tr>
        <tr>
          <td> 83 </td>
          <td> 0x53 </td>
          <td> 123 </td>
          <td> 1010011 </td>
          <td> S </td>
        </tr>
        <tr>
          <td> 84 </td>
          <td> 0x54 </td>
          <td> 124 </td>
          <td> 1010100 </td>
          <td> T </td>
        </tr>
        <tr>
          <td> 85 </td>
          <td> 0x55 </td>
          <td> 125 </td>
          <td> 1010101 </td>
          <td> U </td>
        </tr>
        <tr>
          <td> 86 </td>
          <td> 0x56 </td>
          <td> 126 </td>
          <td> 1010110 </td>
          <td> V </td>
        </tr>
        <tr>
          <td> 87 </td>
          <td> 0x57 </td>
          <td> 127 </td>
          <td> 1010111 </td>
          <td> W </td>
        </tr>
        <tr>
          <td> 88 </td>
          <td> 0x58 </td>
          <td> 130 </td>
          <td> 1011000 </td>
          <td> X </td>
        </tr>
        <tr>
          <td> 89 </td>
          <td> 0x59 </td>
          <td> 131 </td>
          <td> 1011001 </td>
          <td> Y </td>
        </tr>
        <tr>
          <td> 90 </td>
          <td> 0x60 </td>
          <td> 132 </td>
          <td> 1011010 </td>
          <td> Z </td>
        </tr>
      </table>
    </td>
  </tr>
</table>

표에서 대문자 A는 10진수로 65이고 16진수로 0x41 입니다. 이진수 표현은 아래와 같습니다. 

| 문자 | 10진수 | 16진수 | 2진수 |
|:---|:---|:---|:---|
| A | 65 | 0x41 | 0100 0001 |

아스키코드표의 값은 1바이트입니다. 자바에서는 2바이트로 문자를 표현하므로 1바이트 코드값 앞에 0값으로 채운 1바이트를 덧붙여서 사용합니다. 예를 들어 A는 2진수 아스키코드값으로 `0100 0001`이고, 자비에서는 `0000 0000 0100 0001` 입니다. 

```
* 참고 - 인코딩과 디코딩
이렇게 'A'를 문자 코드표를 보고 이진수 "0000 0000 0100 0001"로 바꾸는 것을 인코딩이라고 합니다. 반대로 이진수 "0000 0000 0100 0001"를
문자 코드표를 보고 문자 'A'로 바꾸는 것을 디코딩이라고 합니다.
```

자 이제 문자형 변수에서 'A'를 저장하는 코드를 다시 봅시다.
```
char ch1 = 'A';
```

ch1이라는 변수는 자료형이 `char` 이니까 규칙대로 메모리 2바이트 공간에 `0000 0000 0100 0001` 신호를 저장하면 됩니다. 이제 저 메모리의 값을 직접 읽는다면 이진수 `0000 0000 0100 0001`이니 십진수 65라고 읽을 수도 있습니다.

하지만 우리는 메모리의 주소에 직접 가서 여기 뭐 있냐 하고 보는 것도 아니고 `ch1`이라는 변수를 통해서 값을 읽어옵니다. 그러면 ch1 자료형이 char인 것을 확인한 자바는 해당 값을 유니코드표에서 보고 디코딩 해서 'A'라고 보여주게 됩니다. 

정말 그런지 'A'를 문자, 10진주, 16진수, 2진수로 표현해 문자형 변수에 대입하고 출력하는 예제를 살펴보겠습니다. 
```
package Chap_01_DataType;

public class _Ex02_char {
    public static void main(String[] args) {

        char ch1 = 'A';                 // 자바가 인코딩을 합니다.
        char ch2 = 65;                  // 10진수로 직접 문자의 값을 넣어줍니다.
        char ch3 = 0x41;                // 16진수로 직접 문자의 값을 넣어줍니다.
        char ch4 = 0b0000000001000001;  // 2진수로 직접 문자의 값을 넣어줍니다.

        System.out.println("인코딩 대상 문자: " + ch1);
        System.out.println("10진수 디코딩 결과: " + ch2);
        System.out.println("16진수 디코딩 결과: " + ch3);
        System.out.println("2진수 디코딩 결과: " + ch4);
    }
}
```

![1-28_string_result](https://github.com/user-attachments/assets/17156f3a-45b3-46c3-a0b2-0d1012d24baa)

문자형 변수에 'A'를 뜻하는 값을 다양한 형식으로 각각 대입했습니다. 예상대로 모두 A가 출력되었습니다. 문자형 변수이므로 문자로 디코딩해 출력해준 겁니다.

```
*참고 - 문자열 자료형
문자열이란 문장을 뜻합니다. 문자(char)형은 하나의 글자로 작은 따옴표를 감쌉니다. 하지만 문자열(String)은 글자의 집합으로서 큰 따옴표로 감싼다라는
차이가 있습니다. 자바는 문자와 문자열을 엄격히 구분하고 있기 때문에 주의가 필요합니다. 문자열 변수 선언은 아래와 같습니다.

String str = "Java is Good!"
```

### 3-3. 논리형
논리 자료형은 어떤 변수의 참, 거짓의 값을 나타내는데 사용합니다. 논리 자료형은 다음과 같습니다. 

| 자료형 이름 | 자료형 크기 |
|:---|:---|
| boolean | 1바이트 |

true, false 두 가지 값만 가집니다. 1비트면 될 것 같지만 최소 단위가 1바이트 이므로 1바이트를 사용합니다. 

```
package Chap_01_DataType;

public class _EX03_boolean {
    public static void main(String[] args) {

        // 변수 선언 - boolean
        boolean check1 = true;      // 직접 값 대입 - true
        boolean check2 = false;     // 직접 값 대입 - false
        boolean check3 = (1 < 2);   // 연산 결과를 값으로 대입

        // 결과 출력
        System.out.println("직접 입력한 값 1: " + check1);
        System.out.println("직접 입력한 값 2: " + check2);
        System.out.println("연산 결과: " + check3);
    }
}
```
![1-29_boolean_result](https://github.com/user-attachments/assets/8782ea71-8638-448c-abfe-cfad8ac0bf07)

논리형 변수에 `true`/`false`를 직접 대입하거나 수식의 결과를 대입할 수 있습니다.

### 3-4. 실수형
실수를 사용할 떄도 메모리에 저장될 공간의 크기를 지정해야 합니다. 그런데 실수에는 문제가 있습니다. 

0과 1사이에 실수가 과연 몇 개 있을까요? 수학 시간에 배운 대로라며 무한대입니다. 무한대에 이르는 수들을 컴퓨터에서는 표현할 수 없습니다. 그래서 무한대까지는 아니더라도 가능하면 많은 수를 표현할 수 있도록 정의되어 있습니다.

| 자료형 이름 | 자료형 크기 |
|:---|:---|
| float | 4바이트 |
| double | 8바이트 |

예를 들어 '지정해놓은 크기의 몇 자리는 소수점 아래를 표현하는데 사용한다'는 약속을 정했습니다. 이를 "고정 소수점(fixed point)" 방식이라고 합니다.

![1-30_fixed_point](https://github.com/user-attachments/assets/4685fc01-a5b1-4a8d-81ef-9cb4c2fbf450)

이 방식은 정수부와 소수부의 자릿수가 크지 않으므로, 표현할 수 있는 실수의 범위가 매우 적다는 단점이 있습니다. 

소수점을 표현하는 다른 방법으로 "부동 소수점(floating point)" 방식이 있습니다. 수학 시간에 배운 바와 같이 실수 0.1은 1.0 x $10^{-1}$과 같습니다. 이처럼 가수 부분(1.0)과 지수 부분($10^{-1}$)을 나누어서실수를 표현하는 방식을 부동 소수점 방식이라고 합니다. "IEEE 754" 표준에서 부동 소수점 방식으로 실수를 구하는 수식을 정의해놓았습니다. 부동 소수점 방식을 사용하면 실수를 더 세밀하게 표현할 수 있습니다. 자바도 역시 부동 소수점 방식을 사용합니다. 

$$ \pm(1.m) \times 2^{e-127} $$  

![1-31_float_point](https://github.com/user-attachments/assets/4febcc19-671b-4e71-999b-8046f6cb7fd8)

![1-32_double_point](https://github.com/user-attachments/assets/6799fc1e-514b-457a-a767-3fb934dac5c3)

이렇게 값을 구하면 float형은 소수점 아래 7자리 까지 정밀도를, double형은 소수점 아래 15자리 까지 정밀도를 표현할 수 있습니다(자바에서는 실수 사용 시 기본으로 `double`형을 사용합니다).

그런데 지수와 가수로 나타내는 부동 소수점 방식은 지수로 표현되는 값이 0을 나타낼 수 없습니다. 부동 소수점 방식을 사용한다면 표현할 수 있는 실수 범위는 고정 소수점 방식 보다 늘어나지만, 10진수를 정확하게 표현할 수는 없어서 언제나 근사치로 표현합니다. 따라서 부동 소수점 값을 연산하면 약간의 오차가 발생할 수 있습니다. 애초에 근사치 값이기 때문입니다. 

다음 예제는 부동 소수점 방식의 실수로 연산할 때 발생할 수 있는 오차의 예입니다. 

```
package Chap_01_DataType;

public class _Ex04_DoubleError1 {
    public static void main(String[] args) {

        // 부동소수점의 오차 결과 1
        double num1 = 1.0000001;        // 첫 번째 실수 선언
        System.out.println(num1);       // 결과 출력 

        double num2 = 2.0000001;        // 두 번쨰 실수 선언  
        System.out.println(num2);       // 결과 출력 

        double result = num1 + num2;    // 첫 번째 실수와 두 번째 실수 연산 
        System.out.println(result);     // 연산 결과 출력 
    }
}
```
![1-33_double_error1](https://github.com/user-attachments/assets/1a186ea4-7ca0-41e2-9719-749abb9c8571)

double형 변수에 `1.0000001`과 `2.0000001`을 각각 대입하고 더한 결과를 출력했습니다. 예상으로는 `3.0000002`가 출력되어야 하는데 `3.0000001999999997`이 출력되었습니다. 더하기 결과가 이상하죠? 이처럼 실수의 연산은 오차가 발생합니다.

오차가 발생하는 다른 예제를 하나 더 보겠습니다. 

```
package Chap_01_DataType;

public class _Ex04_DoubleError2 {
    public static void main(String[] args) {

        // 변수 0.0 실수형으로 초기화
        double dNum = 0.0;

        // 반복문으로 0.0 부터 0.1을 1000번 더하기
        for (int i = 0; i < 1000; i = i + 1) {
            
            // 수식 0.1 = 0.0 + 0.1 -> 0.2 = 0.1 + 0.1 -> .... 
            dNum = dNum + 0.1;
        }
        // 결과 출력 
        System.out.println(dNum);
    }
}
```

![1-34_double_error2](https://github.com/user-attachments/assets/d807a9c0-3e09-4de3-95cc-f20229085436)

0.1을 1000번 더합니다. 그 결과를 출력해봅니다. 100을 예상했으나 이번에도 빗나갔습니다. 이처럼 컴퓨터에서 실수를 가지고 수행하는 모든 연산에는 언제나 작은 오차가 존재합니다. 실수형 연산에서 생기는 오차는 자바 뿐만 아니라 모든 프로그래밍 언어에서 발생하는 기본적인 문제입니다. 자바에 대한 오해가 없으시길 바랍니다. 

자, 여기까지의 내용이 어려웠다면 다음만 기억하면 됩니다. 
  - 실수는 정확한 값이 아니고 수식에 의해 저장되는 근사치 입니다. 그러므로 연산 시 오차가 발생합니다.
  - float형은 4바이트이고 double형은 8바이트입니다. 자바는 double형을 기본 실수형으로 사용합니다. float형으로 사용하고 싶다면 명시를 해줘야 합니다.

## 마무리
이번에 배운 자료형을 정리하면 다음과 같습니다. 

| 구분 | 자료형 이름 | 크기 | 자바에서 값의 범위 |
|:---|:---|:---|:---|
| 정수 | byte | 1 Byte | $-2^7$(-128) ~ $2^7$-1(127) |
| 정수 | short | 2 Byte | $-2^{15}$(-32,768) ~ $2^{15}$-1(32,767) |
| 정수 | int | 4 Byte | $-2^{31}$(-2,147,483,648) ~ $2^{31}$-1(2,147,483,647) |
| 정수 | long | 8 Byte | $-2^{63}$(-9,223,372,036,854,775,808) ~ $2^{63}$-1(9,223,372,036,854,775,807) |
| 실수 | float | 4 Byte |   |
| 실수 | double | 8 Byte |   |
| 문자 | char | 2 Byte | Uincode |
| 논리형 | boolean | 1 Byte | true / false |
