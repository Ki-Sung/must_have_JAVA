# 02 자료형 
- 프로그래밍을 이해하려면 하드웨어 동작 원리를 알아야할 필요가 있습니다. 하드웨어를 제어하는 코드의 묶음이 프로그래밍이기 때문입니다. 하드웨어의 동작 이해와 함꼐 자료형을 배워보겠습니다.

## 1. 진수 계산법 
여기서는 자료형을 다룹니다. 사람이 10진수로 값을 입력해도 컴퓨터는 무조건 2진수로 변환해 저장합니다. 그래서 자료형을 다룰 때 진수 변환을 알면 편합니다. 깊고 어려운 내용을 다루기 보다 간단히 진수 계산법을 살펴보고 넘어갑시다.

### 1-1. 지수 계산
지수 계산하는 방법은 학창 시절에 배워서 다 아실 겁니다. 컴퓨터는 2진수를 기반으로 데이터를 관리하기 때문에, 복습하는 차원에서 아래의 표로 정리해보았습니다.

|지수 표현|풀이|10진수 정수값|
|:---|:---|:---|
| $2^0$ | = 1| = 1|
| $2^1$ | = 2| = 2|
| $2^2$ | = 2 x 2| = 4|
| $2^3$ | = 2 x 2 x 2| = 8|
| ... | ... | ... |
|$2^8$|   | = 256 |
| ... |   | ... |

모두 기억나셨죠? 이어서 10진수를 2진수로 바꾸는 방법을 살펴보겠습니다.

### 1-2. 10진수를 2진수로 바꾸기
10진수 11을 2진수로 바꾸려면 1번째 화살표 처럼 더 이상 나눌 수 없는 정숫값이 나머지로 나올 때까지 2로 계속 나누고 2번째 화살표 방향 순서로 배치해면 됩니다. 

![1-22_decimal_to_binary](https://github.com/Ki-Sung/must_have_JAVA/assets/80456601/54e5a5f7-17a0-49b6-9d4f-99600892eec7)

- 결론: 10진수 11 = 2진수 $1011_2$

### 1-3. 2진수를 10진수로 바꾸기
이번에는 2진수 1011을 10진수로 바꾸어 보겠습니다. 1번째 화살표 자리별로 지수 계산을 한 뒤 2번째 화살표 처럼 모든 숫자를 더합니다. 

![1-23_bianry_to_decimal](https://github.com/Ki-Sung/must_have_JAVA/assets/80456601/6065d1cb-e03b-4989-a50b-735f691e5dcb)

- 결론: 2진수 $1011_2$ = 10진수 11

이 정도 내용을 알고 계시면 이후 내용을 보는데 어려움이 없을 것 입니다. 

### 1-4. 계산기를 이용한 진수 변환
Mac OS에서 기본으로 제공하는 계산기를 이용하면 쉽게 진수별 값을 알 수 있습니다. 먼저 10 진수로 선택 후 11을 입력하면 가운데 2진수 표시가 뜹니다. 

![1-24_bianry_can](https://github.com/Ki-Sung/must_have_JAVA/assets/80456601/5482ee1b-e70a-4d39-97e1-053eda392a7c)

## 2. 컴퓨터에서 데이터 처리 방식 
프로그램은 미리 정해진 일을 순서대로 컴퓨터 하드웨어에 전기 신호를 보내서 컴퓨터 하드웨어를 동작시키고 데이터를 표현합니다. 컴퓨터 하드웨어에 신호를 보낼 때 전류를 약하게 보냈다가 강하게 보냈다가 하는 방법을 사용합니다. 이것을 기계어로 숫자 0과 1로 표현하게 되는데, 우리가 마침 알고 있는 이진수와 같은 형태입니다. 

컴퓨터에서 숫자 데이터를 표현하려면 전기 신호를 다음 이진수로 적어놓은 것처럼 보내야 합니다. 

|10진수 숫자|2진수 신호|
|:---|:---|
| 0 | 0 | 
| 11 | 1011 | 
| 255 | 1111 1111 | 

"1 프로그래밍 언어"에서 설명한 것 처럼 1바이트는 비트 8개를 모아놓은 것이고, 1바이트는 컴퓨터에서 정보를 처리하는 기본 단위입니다. 1바이트로 양수만 표현하면 0에서 255까지 표현할 수 있습니다. 1바이트에서 제일 큰 수는 1111 1111 이기 때문입니다. 

255보다 큰 256을 표현하고 싶습니다. 어떻게 해야할까요? 컴퓨터에서 정보를 처리하는 기본 단위가 바이트 이므로 1비트나 4비트만 추가할 수는 없습니다. 바이트 단위로 추가해야 합니다. 예를 들어 8인용 객실만 가진 호텔이 있습니다. 일행이 9명인 손님이 왔습니다. 이러면 방 두 개를 빌려줘야 하겠지요?

따라서 256을 표현하는데 9비트를 사용하지 않고 바이트를 하나 더 사용해 2바이트, 총 16비트를 사용하게 됩니다. 바이트 두 개를 합쳐 하나의 신호로 사용합니다. 256을 표현해 보내는 신호는 다음과 같습니다. 

|10진수 숫자|2진수 신호|
|:---|:---|
| 256 | 1 0000 0000 &larr; 잘못된 표현 | 
| 256 | 0001 0000 0000 &larr; 잘못된 표현 | 
| 255 | 0000 0001 0000 0000 &larr; 올바른 표현 | 

이런 신호로 전달된 데이터를 메모리에 저장할 때도 바이트 단위는 중요하게 사용됩니다. 바이트는 컴퓨터에서 데이터를 처리하는 기본 단위 이면서 메모리 위치를 표시하는 최소 단위 이기도 합니다. 실제로 메모리에는 1바이트 마다 주소가 매겨져 있습니다. 

![1-25_memory_adress](https://github.com/Ki-Sung/must_have_JAVA/assets/80456601/edb04662-99db-41f6-92dd-8c7bb95b2afa)

메모리는 8비트, 즉 1바이트씩 저장하는 구조라서 방마다 주소를 매겨 놓았습니다. 그러므로 8비트 보다 적게 보내도 방 하나를 차지합니다. 실제로도 바이트 단위로 전달받아 저장하게 됩니다. 따라서 숫자 256을 저장하려면 신호를 '0000 0001 0000 0000'으로 받아서 메모리 주소 2개를 사용해서 저장합니다. 

- **참고**: 32비트 CPU에서 처리할 수 있는 최대 메모리 크기
  - 표현할 수 있는 메모리 주소의 범위가 0 ~ $2^{32}$ - 1, 총 크기는 $2^{32}$(=4GB)입니다. 2진수로 표현하면 너무 길게 써야해서 16진수로 나타내면 메모리 주소는 00000000 부터 FFFFFFFF 까지 입니다.
  - 그래서 32비트 컴퓨터에서는 4GB 이상의 메모리를 사용할 수 없습니다. 물리적으로 존재해도 소프트웨어적으로 주소를 표시해줄 수 없기 때문입니다. 즉, 장치에서 1GB 메모리가 있을 때 4GB 메모리를 추가해서 물리적으로 5GB가 되더라도 4GB밖에 사용할 수 없습니다.
    ![1-26_sperate_memory](https://github.com/Ki-Sung/must_have_JAVA/assets/80456601/afec3c3f-7b58-490c-982e-cd135e878a2b)

## 3. 자바 기본 자료형
개인용 컴퓨터도 하드디스크가 테라바이트(Terabyte, TB) 시대 입니다. 그런데 메모리는 아직도 8GB, 16GB, 32GB, 정말 많으면 48GB 입니다. 하드디스크에 비해 메모리가 월등히 비쌉니다. 컴퓨터가 나온 초창기에도 사정은 비슷했습니다. 그래서 작고 비싼 메모리를 아껴 효율적으로 사용할 필요가 있었습니다. 효율적으로 데이터를 사용하고 메모리를 아껴 쓰려면 자료형을 잘 활용해야 합니다. 

자바에서 제공하는 기본 자료형은 크게 정수형, 문자형, 논리형, 실수형으로 나눌 수 있습니다. 각각에 대해 알아보겠습니다. 

### 3-1. 정수형 
정수 자료형은 숫자를 담는 자료형입니다. 예를 들어 국어, 영어, 수학 점수를 저장하는 데는 큰 저장 공간이 필요하지 않습니다. 100점 만점이기 때문에 1바이트면 충분합니다. 1바이트로 255까지 처리할 수 있으니까요. 점수를 저장하는데 4바이트를 사용한다면 3바이트를 낭바하게 됩니다. 그래서 상황에 따라 사용하는 데이터의 최대 크기를 정할 필요가 생겼습니다. 

그런데 A 데이터는 메모리 한 칸 사용, B 데이터는 메모리 두 칸 사용 이렇게 표현하면 말하는 사람이나 듣는 사람이나 좀 불편합니다. 그래서 단위에 `byte`, `short`, `int`, `long`이라는 이름을 붙입니다.

| 용도 | 자료형 이름 | 값의 크기 | 자바에서 값의 범위 |
|:---|:---|:---|:---|
| 1바이트 사용할 때 | byte | $2^8$ | $-2^7$(-128) ~ $2^7$-1(127) |
| 2바이트 사용할 때 | short | $2^{16}$ | $-2^{15}$(-32,768) ~ $2^{15}$-1(32,767) |
| 3바이트 사용할 때 | int | $2^{32}$ | $-2^{31}$(-2,147,483,648) ~ $2^{31}$-1(2,147,483,647) |
| 8바이트 사용할 때 | long | $2^{64}$ | $-2^{63}$(-9,223,372,036,854,775,808) ~ $2^{63}$-1(9,223,372,036,854,775,807) |

앞에서 말한 것처럼 1바이트로는 $2^8$, 총 256가지를 구분할 수 있습니다. 자 이제 숫자 데이터를 표현할 때를 정리해보겠습니다.

| 구분 | 값의 범위 | 경우의 수 |
|:---|:---|:---|
| 양수만 표현 | 1 ~ 256 | 256가지 | 
| 0 포함 양수 표현 | 0, 1 ~ 256 | 256가지 | 
| 음수까지 표현 | -128 ~ -1, 0, 1 ~ 127 | 256가지 양수를 반으로 나누어 음수에 배치, 그리고 양수쪽에서 하나를 빼서 0을 포함 |

자바에서는 '음수까지 표현'한 방식을 자료형 크기로 사용합니다. 그래서 자바에서는 데이터를 표현할 때 "이 데이터는 값의 범위가 -128 부터 127까지 사이에서 저장할 수 있겠군. 그러면 메모리 주소 한 칸을 사용하면 충분하겠어. 이런 상황이면 이 데이터는 byte 자료형으로 사용하면 되겠어." 이렇게 표현하는 겁니다. 나머지 자료형도 같은 방식으로 이해하고 똑같이 해석하면 됩니다. 

이것을 변수에 적용하려면 아래와 같습니다. 다 같은 십진수 1을 변수에 대입하지만 메모리에 값이 저장될 때는 다르게 동작합니다.

![1-27_int_datatype](https://github.com/Ki-Sung/must_have_JAVA/assets/80456601/84827d27-9fa9-4b30-ae53-aaaba728f947)

num1 변수는 byte 자료형으로 만들었습니다. 이제 이 변수와 이 변수의 자료형을 보면서 우리는 '메모리 주소 하나를 사용하여 데이터를 저장할 수 있겠구나'하고 순간적으로 생각하게 될 것입니다. 이게 서로의 약속이니까요. 그리고 십진수 1을 대입합니다. 그러면 컴퓨터는 십진수 1을 이진수 0000 0001로 변환하여 메모리에 저장하게 됩니다. 

나중에 num1을 사용하면 컴퓨터는 "아 num1은 byte 자료형이니까 저장된 위치에서 메모리 주소 한 칸만 읽어서 꺼내주면 되겠구나" 하면서 값을 읽어 알려줍니다. 이때 이진수로 알려주면 우리가 당황하니까 십진수로 바꾸어서 알려줍니다.

나머지 변수들도 마찬가지 방식으로 작동합니다. 

그러면 long 자로형에다 1을 저장하는 건 너무 낭비가 아니냐 할 수도 있습니다. 변수를 선언할 때는 1을 대입했지만 나중에 큰 값을 다시 대입할 수도 있습니다. 지금 당장 저장하는 값이 작다고 하더라도 앞으로 저장할 값의 범위에 따라 변수 자료형을 지정해주면 됩니다.\
(프로그래밍에서 자료형을 정할 때는 '메모리에서 데이터 저장 효울성'을 따져야 한다는 것을 명심해야 합니다.)
