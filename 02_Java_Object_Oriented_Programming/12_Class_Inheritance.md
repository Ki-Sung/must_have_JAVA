# 12 클래스의 상속 
- 자바 클래스의 상속을 알아보고, 상속과 관련된 오버라이딩, 추상 클래스, 인터페이스, 다형성을 알아봅니다. 

## 1. 상속 
자바는 객체지향 언어입니다. 그리고 객체 지향 언어의 가장 큰 특징 중 하나가 바로 상속입니다. 
![189_class_inheritance](https://github.com/user-attachments/assets/542a7a30-9904-42aa-9372-2f75b5f30d6e)

상속이란 클래스가 가지고 있는 맴버를 다른 클래스에게 계승시키는 겁니다. 현실 세계에서의 상속과 같습니다. 상속한 멤버는 자식 클래스에서 정의하지 않아도 사용할 수가 있으며, 자식 클래스 내에서 맴버를 추가로 정의해도 사용할 수 있습니다. 게임 속 유닛 상속 관계를 그려보면 위의 이미지와 같습니다. 

상속을 받으면 똑같은 기능을 매번 만들지 않아도 됩니다. 처음부터 모두 새로 준비하는 것보다는 훨씬 간단하고 편리합니다. 이것이 상속이 가지는 편리함입니다. 

상속은 다음과 같은 장점을 제공합니다. 
- 클래스 간의 전체 계층 구조를 파악하기 쉽습니다.
- 재사용성 증대: 기존 클래스에 있는 것을 재사용할 수 있습니다.
- 확장 용이: 새로운 클래스, 데이터, 메서드를 추가하기가 쉽습니다.
  - 예) 고스트, SCV 등 추가할 유닛이 생기면 쉽게 추가할 수 있습니다.
- 유지보수 용이: 데이터와 메서드를 변경할 때 상위에 있는 것만 수정하여 전체적으로 일관성을 유지할 수 있습니다.
  - 예) 종족 간 밸런스를 맞추고자 테란 유닛의 기본 HP를 일괄 변경할 수 있습니다.
 
이때 상속 대상 클래스와 상속을 받은 클래스를 다음과 같이 다양한 이름으로 부를 수 있습니다.

| 상속 대상 클래스 호칭 |  | 상속을 받은 클래스 호칭 |
|:---|:---:|:---|
| 슈퍼 클래스(Supper Class) | &larr;&rarr; | 서브 클래스(Sub Class) |
| 부모 클래스(Parent Class) | &larr;&rarr; | 자식 클래스(Child Class) |
| 기반 클래스 | &larr;&rarr; | 파생 클래스 |
| 조상 클래스 | &larr;&rarr; | 자손 클래스 |
| 상위 클래스 | &larr;&rarr; | 하위 클래스 |

그런데 모든 것을 상속받게 될까요? private으로 접근 제한이 되어 있는 멤버들은 서브 클래스로 상속되지 않습니다. 이것도 현실의 상속과 똑같습니다.

자바에서 이런 자식 클래스를 코드로 구현할 때 다음과 같이 extends 예약어를 사용합니다. 
![190_class_name](https://github.com/user-attachments/assets/5a0dc6f2-0864-465e-b4f0-759316ccefaa)

프로그램에서 어떻게 활용하는지 살펴보겠습니다. 
![191_class_inheritance_example_code](https://github.com/user-attachments/assets/2e9b534a-a69c-4bc4-84c5-316f686cee61)
![192_class_inheritance_example_code_result](https://github.com/user-attachments/assets/6cc797b2-7061-4d51-8429-28077fd50da9)

`Unit`클래스를 부모 클래스로 삼아  `Marine`과 `Medic` 클래스를 정의해 사용하는 예제입니다. 

`1번`먼저 `Unit` 클래스를 정의합니다. 맴버 변수 2개와 메서드 하나를 정의합니다. 
`2번` `Unit`을 상속하여 `Marine` 클래스를 정의합니다. 상속을 통해 부모 클래스의 맴버를 그대로 계승했기에 `Marine`은 맴버 변수로 name, hp, attack 세 개를 사용할 수 있고, 메서드로 printUnit()과 printMarine()을 사용할 수 있습니다. `3번` printMarine() 메서드가 호출되면 `4번` printUnit() 메서드를 호출하고 추가적으로 공격력 정보까지 출력해줍니다. `Marine` 클래스에 printUnit() 메서드가 직접적으로 보이지 않지만 상속받은 기능이기에 이렇게 사용할 수 있는 것입니다.

`5번` `Medic` 클래스에`Unit` 클래스를 상속받아 정의합니다. `6번` `Medic` 클래스에서 사용할 맴버 변수와 `7번` `Medic` 클래스에서 사용할 메서드를 추가합니다. 

`8번` `Marine` 클래스의 객체를 만듭니다. `9번` name과 `10번` hp는 `Marine` 클래스에서는 볼 수 없지만 상속받은 `Unit` 클래스에 정의된 맴버 변수이기 때문에 `Marine` 클래스의 객체에서도 이와 같이 사용할 수 있습니다. 

상속을 받으면 이렇게 부모 클래스의 기능을 구현하지 않고 바로 사용할 수 있어 편리합니다. 

> **자바와 다중 상속**
> 
> 자바는 여러 클래스를 동시에 상속하는 다중 상속을 지원하지 않습니다. 예를 들어 두 개 이상의 상위 클래스에 같은 이름의 메서드가 정의되어 있다면, 다중 상속을 받는 하위 클래스는 어떤 클래스의 메서드를 상속받아 사용해야 할지 헷갈리게 됩니다. 다중 상속을 지원하는 C++ 같은 언어는 이것을 문법적으로 구분해서 사용하지만, 자바는 이런 모호함 자체를 없애기 위해 다중 상속 대신 단계별 상속을 사용합니다.

## 2. 오버라이딩
어떤 메서드명을 만들고 싶은데 이미 부모 클래스에서 사용되었기에 사용할 수 없다고 한다면 메서드명을 짓기가 매우 힘들어질 겁니다. 상속이 부모와 자식 관계뿐 아니라 계속 상속이 일어나서 조상과 후손의 관계까지 된다면 메서드명을 겹치지 않게 만들기가 더욱 힘들게 됩니다(메서드의 오버로딩, 클래스의 맴버 변수와 매개변수를 구분하기 위한 this를 사용할 때도 똑같음). 

오버라이딩(overriding)이란 상속된 메서드와 동일한 이름, 동일한 매개변수를 가지는 메서드를 정의하여 메서드를 덮어쓰는 것을 말하며, 반환값의 데이터 타입도 같아야 합니다.

오버라이딩은 다음과 같이 두 가지 목적으로 사용합니다. 
- 상속받은 부모 클래스 메서드의 기능 변경
- 상속받은 부모 클래스 메서드에 기능 추가

예제를 통해 살펴보겠습니다.

![193_class_overriding_example_code](https://github.com/user-attachments/assets/8913976d-6131-4582-b013-aa0ed8be74df)
<img width="1195" alt="194_class_overriding_example_result" src="https://github.com/user-attachments/assets/9ce6893e-5c2e-4cc7-831d-3e19b1d3e747">

`1번` Unit 클래스에서 doMove() 메서드를 정의했습니다. 그런데 Marine 클래스도 메서드 이름을 doMoveMarine() 보다는 doMove()로 사용하고 싶은 겁니다. 그래서 `2번`처럼 메서드명을 사용했습니다. 이렇게 되면 부모 클래스의 doMove() 메서드와 자식 클래스의 doMove() 메서드가 헷갈리게 됩니다. 그래서 부모에서 상속받은 메서드에는 `super` 예약어를 이용하여 구분해서 불러 줄 수 있게 합니다. Marine 클래스의 doMove() 메서드는 `3번`부모의 doMove() 메서드를 호출하고 `4번` 자체 기능을 추가했습니다. 

그에 반해 Medic 클래스는 `5번`같은 이름으로 doMove() 메서드를 정의했습니다. 그러나 부모의 doMove() 메서드는 따로 호출해주지 않았기 때문에 부모의 기능은 사용하지 않고 자체 구현한 기능만을 사용하게 됩니다.

이처럼 오버라이딩으로 구현한 메서드는 Marine 클래스처럼 기능을 추가하나거나, Medic 클래스 처럼 기능을 대체하게 됩니다. 

## 3. 상속이 제한되는 final 
final은 필드나 메서드, 클래스에 붙이는 예약어입니다. 

```
final int MAX_NUM = 100;
final class Marine
{

}
```

final을 붙였을 때를 정리하면 다음과 같습니다. 

| 상속 대상 클래스 호칭 | 상속을 받은 클래스 호칭 |
|:---|:---|
| 변수 | final 변수는 상수를 의미합니다. |
| 메서드 |  final 메서드는 하위 클래스에서 오버라이딩 할 수 없습니다. |
| 클래스 | final 클래스는 상속을 할 수 없습니다. |

final 상수 때 처럼 클래스도 "이 클래스가 마지막이야! 더 이상 상속하면 안 돼!"라는 의미로 final을 클래스 앞에 붙여준 것이라고 생각하면 됩니다. 

만약 클래스의 일부 메서드를 상속 제한하려면 메서드에 접근 제한자 `private`를 사용합니다.

## 4. 추상 클래스 
여태까지 우리가 만든 메서드들은 구체적인 기능을 가지고 있었습니다. 이런 점에 초점을 맞춰서 메서드를 표현할 때 구상(concrete) 메서드라고 합니다. 반면에 추상(abstract) 메서드라는 것이 있습니다.

구체적인 처리 내용을 기술하지 않고, 호출하는 방법만 정의한 메서드를 추상 메서드라고 합니다. 
```
// 구상 메서드
public int adder (int n1, n2)
{
    return n1 + n2;
}

// 추상 메서드
abstract public int adder (int n1, n2);
```

그리고 이런 추상 메서드를 가진 클래스 추상 클래스라고 합니다. 클래스의 코드 길이가 매우 길 때 중간에 추상 메서드가 하나 있다면 추상 메서드가 있는지 파악이 힘들 수 있습니다. 그래서 `abstract` 표시를 클래스 앞에 붙어 추상 메서드를 가진 클래스라고 표시해줍니다. 

<img width="1200" alt="195_abstract_class" src="https://github.com/user-attachments/assets/9d0b1e83-8d64-4065-89f9-5cc5af9f8785">

만약에 이런 추상 클래스로 객체를 직접 만들게 되면 추상 메서드를 어떻게 동작시켜야 할지 알 수 없기 때문에 추상 클래스로는 객체를 생성할 수 없습니다.

그럼 이런 추상 클래스를 왜 사용하는 걸까요? 상속받은 클래스의 기능을 미리 저장히기 위해서입니다. 이 클래스를 상속받은 클래스는 이런 기능은 반드시 있어야 한다는 것입니다. 그런데 앞으로 어떤 클래스가 상속받을지 모르므로 그 기능을 구체적으로 미리 만들어놓을 수 없을 때 사용합니다. 

앞에서 사용한 Unit 클래스는 유닛의 기본 설계도이므로 테란의 Marine, 프로토스의 Zealot, 저그의 Zergling 클래스는 이 Unit 클래스를 상속해 만들어야 합니다. 셋 다 이동은 해야하니까 유닛에 doMove() 메서드를 만들어놓았습니다. 이러면 상속받은 클래스들은 다 이동에 관련한 기능을 수행할 수 있습니다. 

그런데 세 종족의 이동 방법이 다 다릅니다. 이동 방법이 다 다르기 때문에 미리 기능을 만들어놓아도 오버라이딩해서 기능을 다 수정해야 합니다. 그러므로 미리 이동 기능을 만들어놓은 것은 의미가 없습니다. 다만 혹시라도 까먹고 doMove() 메서드를 구현하지 않을까봐 추상 메서드로 지정해놓습니다. 이러면 상속받은 클래스에서는 추상 메서드를 구상 메서드로 만들지 않으면 객체를 생성할 때 에러가 발생하게 되므로 까먹지 않고 구현하게 됩니다. 

일년이 지나고 나서 다시 유닛이 하나 추가되더라도 상속을 받아 만들게 되면, 추상 메서드의 특성상 이동 기능을 혹시라도 잊고 안 만들면 에러가 나므로 추상 메서드를 구상 메서드로 구현해주게 됩니다. 이렇게 비슷한 객체를 추가할 때 설계 원칙이 유지되는 것입니다. 

예제를 통해 확인해보겠습니다. 
![196_abstract_class_example_code](https://github.com/user-attachments/assets/a432aa4e-c494-472e-b1a0-f6346b3066fd)
![197_abstract_class_example_code_result](https://github.com/user-attachments/assets/0e44cfac-4a11-4886-b34f-3a084ebd929c)

Unit 클래스는 "1번" 4번 라인에서 추상 메서드를 가지고 있으므로 추상 클래스입니다. 그래서 abstract 예약어가 붙어 있습니다. 

이 Unit 클래스를 상속한 "2번" Marine 클래스는 doMove() 메서드의 구체적인 기능을 구현하고 있습니다. 이 Unit 클래스를 상속한 "3번" Zergling 클래스는 doMove() 메서드의 구체적인 기능을 구현하고 있습니다. 

"4번" 객체를 생성하고 "5번" 객체의 메서드를 호출합니다. 

"6번" 객체를 생성하고 "7번" 객체의 메서드를 호출합니다. 

각 클래스에서 추상 메서드를 구상 메서드로 구현한 내용이 출력됩니다.

## 5. 인터페이스 
인터페이스란 상속 관계가 아닌 클래스에 기능을 제공하는 구조입니다. 추상 클래스처럼 추상 메서드로 기능을 제공합니다. 

자바 7까지 인터페이스는 정의와 추상 메서드만을 제공했지만 자바 8부터는 디폴트 메서드, 스태틱 메서드까지 인터페이스 맴버가 될 수 있게 되어 활용성이 높아졌습니다. 인터페이스를 알아보면서 추상 클래스와의 관계도 함께 알아보겠습니다. 

### 5-1. 인터페이스 구현 
인터페이스의 구성을 추상 클래스의 구성과 비교하면 다음과 같습니다.

![198_abstract_class_interface](https://github.com/user-attachments/assets/81c9d230-36bf-4e4c-976d-6cbdca31c5b2)

줄여서 다음과 같이 작성합니다(디폴트 메서드는 뒷 부분에서 따로 다룹니다).

![199_interface](https://github.com/user-attachments/assets/b7720adc-2803-4693-940d-01dadb7e951c)

인터페이스끼리 상속도 가능합니다. 하지만 인터페이스가 일반 클래스를 상속할 수는 없습니다. 

![200_interface_extends](https://github.com/user-attachments/assets/2b8b2672-6fa6-4f75-af60-49906adff8e7)

그리고 인터페이스에 한해서 다중 상속도 가능합니다.

![201_interface_multi_extends](https://github.com/user-attachments/assets/e0fdf075-1b4b-4143-ac4d-09bb7c823025)

인터페이스는 아래와 같이 implements 예약어를 이용해서 코드를 작성합니다. 이후는 추상 클래스의 사용 방법과 동일합니다. 인터페이스의 메서드는 추상 메스드이므로 implements 예약어를 사용했다면 반드시 추상 메서드를 구상 메서드로 오버라이딩해서 구현해주어야 합니다. 이렇게 클래스에서 인터페이스를 이용하도록 하는 것을 '인터페이스 구현'이라고 합니다.

![202_Interface_extend_concrete_class](https://github.com/user-attachments/assets/dacce9e0-c859-4f0a-b18d-b4beb46d76cf)

- 클래스의 상속은 extends 예약어 사용
- 인터페이스의 구현은 implements 예약어 사용

이런 인터페이스는 한 번에 여러 개를 구현할 수도 있습니다. 상속은 다중 상속이 불가능했지만 인터페이스는 다중 구현이 가능합니다. 

![203_multi_interface](https://github.com/user-attachments/assets/8f01a455-6276-4f86-aaf5-ec07926fa391)

상속과 인터페이스를 동시에 사용한다면 아래와 같은 순서를 따릅니다. 앞에서 먼저 상속 표시를 해주고, 뒤에서 인터페이스를 필요한 만큼 표시해줍니다.

![204_multi_intergace_2](https://github.com/user-attachments/assets/27486bde-a612-4d91-8beb-ef29d9358ab5)

인터페이스를 사용하는 간단한 예제를 만들어보겠습니다. 

![205_interface_example_code1](https://github.com/user-attachments/assets/d9b5dec7-6302-40f5-bfa8-8b41f3eaaa2c)

`1번` 추상 메서드 greet()가 있는 인터페이스를 만듭니다. `2번` 추상 메서드 talk()가 있는 인터페이스를 만듭니다. `3번` 아침에 관련된 클래스를 Morning 클래스로 만듭니다. 인사와 인사말을 기능으로 추가합니다. 

`4번` 프로그램이 여기서 시작합니다. `5번` Morning 클래스를 이용하여 객체를 만듭니다. `6번` 참조 변수를 이용하여 인터페이스의 추상 메서드를 구현한 greet() 메서드를 호출합니다. 

`7번` 참조 변수를 이용하여 인터페이스의 추상 메서드를 구현한 talk() 메서드를 호출합니다.

아침에 받드시 인사와 인사말을 나눠야 하는 것은 아닐 겁니다. 클래스 Morning의 본질은 아니라는 이야기입니다. 그냥 Morning 클래스에 단순한 기능을 추가하는 것이므로 기능은 인터페이스로 만들고 그 인터페이스를 구현한 것입니다.

### 5-2. 인터페이스와 추상 클래스의 차이 
인터페이스와 추상 클래스는 둘 다 추상 메서드를 사용한다는 점에서 똑같은 것 같은데 왜 따로 존재하는 걸까요?

테란 배럭스(Barracks), 팩토리(Factory), 벙커(Bunker)는 모두 다 건물입니다. 그러므로 모든 건물의 공통 기능은 상속을 받아 중복으로 만들지 않게 합니다. 이렇게 상속을 통해 코드의 중복을 막고 코드의 재사용성을 높입니다.

이제 테란 건물의 특수 기능인 건물을 상공으로 띄워서 이동하고 다시 땅으로 착지하는 기능을 추가하려고 합니다. 이때 상위 클래스인 Building에 이런 기능을 수행하는 메서드를 추가하면 Bunker 클래스를 통해 생성되는 건물은 원래 이동이 불가능해야 하는데 하늘을 날아서 이동하는 기능을 갖게 되므로 문제가 발생합니다. 이 경우 기능이 필요 없는 건물에서 기능을 오버라이딩해서 기능이 없는 것처럼 만들어도 되지만, 상속받는 모든 건물에 그렇게 처리를 하는 방식은 비효율적입니다. 이때 인터페이스를 사용해서 이동이 필요한 건물에만 기능을 구현하면 됩니다. 

![206_building_terran_structure](https://github.com/user-attachments/assets/1995b6ce-10b4-4725-bebd-4385cd726194)

이처럼 클래스 간의 상속 관계를 통해 건물이라는 본질을 유지하게 하려면 추상 클래스를 통한 상속 기능을 사용하고, 단지 기능만을 구현하려면 인터페이스를 사용하면 됩니다. 

이제 앞에서 예를 들었던 스타크래프트 건물을 구현해보겠습니다. 해당 게임을 잘 알면 더 이해가 빠를 수 있겠지만 그렇지 않더라도 인터페이스에 대한 이해가 생겼다면 코드를 이해하는데 문제가 없을 겁니다.

![207_terran_building_example_code](https://github.com/user-attachments/assets/4d543059-102e-4413-9b28-eb972a17241f)
![208_terran_building_example_code_result](https://github.com/user-attachments/assets/ddd479b0-e101-4a66-88a9-f08395fdcf2f)

모든 건물은 `1번` 상위 추상 클래스 Building을 상속받아 `2번` doBuild() 메서드를 구현하고 있습니다. 추상 클래스 Building을 상속받았다면 혹시라도 건물의 기능을 빼먹고 안 만드는 실수를 하지 않게 될 겁니다. 건물이라면 받드시 만들어야 할 기능이 추상 메서드로 강제되어 있기 때문입니다. 

그리고 날아서 이동을 해야하는 건물에만 `3번` 인터페이스 Fly를 구현하고 있습니다.

### 5-3. 디폴트 메서드
자바 8에 디폴트 메서드가 제공되어 하위 호환성을 유지하면서 기존 인터페이스에 새로운 기능을 추가할 수 있게 되었습니다. 

어떤 인터페이스를 구현한 클래스가 이미 사용되고 있는 상태에서 새로운 클래스가 그 인터페이스를 구현하면서 기능이 부족해서 기능을 추가하고자 합니다. 그러면 기존에 그 인터페이스를 사용하던 모든 클래스에 추가된 기능을 구현해야 하는 불편함이 생깁니다. 이렇게 기존에 한 번 만들어진 인터페이스에는 기능을 추가하기가 어려웠습니다. 

![209_default_method1](https://github.com/user-attachments/assets/8ae9a468-71ed-4433-89ee-98d71b6ad0f3)

물론 상속을 사용하면 해결할 수는 있습니다만 같은 이름으로 사용하고, 관리하고 싶은 겁니다. 앞에도 여러 번 나왔지만 항상 네이밍이 문제입니다. 이런 문제점을 디폴트 메서드를 사용하면 해결할 수 있습니다.

![210_default_method2](https://github.com/user-attachments/assets/67696fc6-c094-4556-8c5a-8730e2efeaef)

`Tip` 디폴트 메서드는 3번에서 오버라이딩으로 다시 구현될 것이므로 1번에서 구체적인 기능 구현 없이 중괄호만 사용해도 됩니다.

기존 클래스와의 호환성을 위해서는 이와 같은 방법으로 사용할 수도 있고, 새로 생성되는 클래스를 위한 공통 기능을 제공하는 용도로도 사용될 수 있습니다.

## 6. 다형성
상속한 클래스의 객체는 슈퍼 클래스로도 서브 클래스로도 다를 수 있습니다. 이렇게 하나의 객체와 메서드가 많은 형태를 가지고 있는 것을 다형성(polymorphism)이라고 합니다. 

![211_polymorphism](https://github.com/user-attachments/assets/1398f5b5-7275-4f99-b981-a688425fdff5)

위 그림과 같이 Super 클래스를 상속받은 Sub 클래스가 있다고 합시다. 이럴 경우 하위 클래스 객체를 상위 클래스형의 변수에 대입하여 사용할 수 있습니다. 메모리에 객체가 만들어진 모습을 보면 왜 가능한지를 알 수 있습니다. 

![212_polymorphism_memory](https://github.com/user-attachments/assets/192131d9-716a-4aa2-a019-6558ba0eb48c)

이 경우 실제 객체는 Sub 클래스의 설계도를 이용해 합에 만들어져 있지만 스택에 만들어진 변수는 Super의 설계도를 이용합니다. 그러므로 obj 변수는 설계도상 name은 몰라서 못 쓰겠지만 나머지 price나 getPrice() 메서드를 사용할 수는 있습니다. 

하지만 상위 클래스의 객체를 하위 클래스형의 변수로 대입할 수는 없습니다. 역시 메모리에 객체가 만들어진 모습을 보면 왜 불가능한지를 알 수 있습니다. 

![213_polymorphism_memory_2](https://github.com/user-attachments/assets/9f1d5d21-d348-4189-ad16-a9b40ba5b1cc)

실제 객체는 Super 클래스의 설계도를 이용해 힙에 만들어져 있습니다. 그런데 스택에 만들어진 변수가 Sub의 설계도를 이용하게 된다면, name이라는 변수에 접근하려고 할 때 100% 에러가 발생하게 됩니다. 자바 컴파일러의 입장에서 에러가 날 게 뻔한 이런 상황을 허용하지 않는 겁니다. 

여기서 중요 포인트는 '자식 클래스의 객체는 부모 클래스형의 변수에 대입할 수 있다(자식 클래스의 인스턴스를 부모 클래스 타입의 변수에 대입할 수 있음을 의미).'만 기억하면 됩니다.

예제를 통해서 실제 코드에서는 어떻게 사용하는지 살펴보겠습니다. 

![214_polymorphism_example](https://github.com/user-attachments/assets/0ba29a0b-c044-4f30-afa4-f5c7172530d9)
![215_polymorphism_example_result](https://github.com/user-attachments/assets/ff3879d6-3fcc-42fe-8474-231178023cac)

`1번` 추상 클래스를 정의합니다. 이 클래스를 상속하는 클래스는 plus() 메서드는 반드시 구현하라는 의미로 추상 메서드로 지정해두었습니다.

`2번` 추상 클래스 Calc를 상속한 MyCalc 클래스를 만들고 정의합니다. 

`3번` 객체를 만들고 객체를 나타내는 클래스형 변수에 참조 값을 대입해줍니다(우리가 평소에 사용하던 방식).

그런데 다형성을 이용하여 `4번` 객체를 만들고 변수에 참조 값을 대입시켜줄 수도 있습니다. 

다만, 이 경우는 앞의 설명처럼 상위 클래스의 설계도로는 하위 클래스의 모든 것을 알 수 없기에 `5번` 처럼 사용 불가능한 멤버가 생기게 됩니다. 

단순히 하위 클래스 객체를 상위 클래스형의 변수에 대입하여 사용할 수 있다는 것을 확인하기 위한 예제입니다. 

그럼 이 다형성을 왜 사용하는지 다음 예제를 통해 알아보겠습니다.

![216_polymorphism_example2](https://github.com/user-attachments/assets/b18c87bb-1aea-430e-b39b-450b38f340e9)
![217_polymorphism_example2_result](https://github.com/user-attachments/assets/1694cfca-888c-4c3a-a69f-dbcf025efb12)

이 예제의 핵심은 `1번`코드 영역입니다. 

humanCreate() 메서드는 입력되는 매개변수에 따라 두 가지 타입의 객체를 만드는데 메서드의 반환값은 하나밖에 지정을 못합니다. 이럴 때는 `2번`객체를 만들고 상위 클래스형의 변수에 넣어서 반환해줄 수 있습니다. 24번, 25번 라인을 주석 처리하고 `3번`에서처럼 사용하면 자동 형변환이 됩니다. 

이렇게 클래스도 자동 형변환이 이루어집니다. 

다형성을 활용하게 되면, 상위 클래스 타입인 Human으로 하위 클래스 객체를 다룰 수 있습니다. 이는 코드의 유연성과 재사용성을 높이는데 도움을 줍니다. 

## 7. instanceof 연산자 
instanceof는 객체가 지정한 클래스형의 객체인지를 조사하는 연산자입니다.

![218_instanceof_1](https://github.com/user-attachments/assets/824009d0-f897-498d-bebd-191735f939e1)

instanceof는 지정한 인터페이스를 오브젝트가 구현하고 있는지를 조사할 수도 있습니다.

![219_instanceof_2](https://github.com/user-attachments/assets/04bc853d-c037-4192-be88-2aa60dc4a15f)

예제를 만들고 어떻게 사용하는지 알아보겠습니다. 

![220_instaceof_example1](https://github.com/user-attachments/assets/025ef2ac-55ce-40bc-82f7-47527bca08af)
![221_instaceof_example1_result](https://github.com/user-attachments/assets/943f4b62-6b06-4f4b-a2ac-1609fdc60ae0)

`1번`Cat 클래스를 이용하여 객체를 만들고 상위 클래스형의 변수 test1에 참조 값을 대입했습니다. 그런데 Cat도 Dog도 다 이런식으로 다형성을 이용한 코드 작성이 가능하기 때문에 실제 어떤 객체의 참조 값이 들어와 있는지 검사해서 사용하고 싶은 겁니다. 

`1번`test1에 있는 참조 값이 Cat의 객체를 가리키는지 Dog의 객체를 가리키는지 조사하여 그에 따른 코드를 진행합니다. 

instanceof 연산자는 결국 다형성을 잘 사용하려고 사용하는 연산자입니다.

instanceof와 다형성을 사용하는 예제를 하나 더 만들어보겠습니다. 
![222_polymorphism_example3](https://github.com/user-attachments/assets/f5800be3-3c4d-4534-a498-95b69689a7fd)
![223_polymorphism_example3_result](https://github.com/user-attachments/assets/e0caa85a-af33-4a2b-bd2e-0972cde279ed)

이번 예제의 핵심은 `1번`입니다. 매개변수(Instance)로 어떤 형태의 객체를 참조하는 변수가 들어올지 알 수 없기 떄문에 아예 상위 클래스로 지정해두는 겁니다. 이러면 하위 클래스를 매개변수로 넘겨도 자동으로 형변환되서 매개변수로 들어오게 됩니다. 

이후 `2번`, `3번`에서처럼 원래의 형태로 다시 형변환해서 사용하는 겁니다. 

`Tip` 이런 형태의 사용법을 숙지하고 익숙해져야 합니다. 자바 기초에서 벗어나게 되면 모든 곳에서 이런 패턴의 코드를 구현하게 되며, 다형성은 자바 프로그래밍 전반에서 사용됩니다.

### 학습 마무리 - 핵심 요약 
1. "**상속**"이란 클래스가 가지고 있는 맴버를 다른 클래스에게 계승시키는 겁니다.
2. "**오버라이딩**"이란 상속된 메서드와 동일한 이름, 동일한 인수를 가지는 메서드를 정의하여 메서드를 덮어쓰는 겁니다. 반환값의 형도 같아야만 합니다.
3. "**final 상수**"는 "이 클래스가 마지막이야! 더 이상 상속하면 안 돼!"라는 의미로 final을 클래스 앞에 붙여주는 것이라고 생각하면 됩니다.
4. 구체적인 처리 내용을 기술하지 않고, 호출하는 방법만을 정의한 메서드를 "**추상 메서드**"라고 합니다.
5. "**인터페이스**"란 상속 관계가 아닌 클래스에 기능을 제공하는 구조입니다. 추상 클래스처럼 추상 메서드로 기능을 제공합니다.
6. 상속한 클래스의 객체는 슈퍼 클래스로도 서브 클래스로도 다룰 수 있습니다. 이렇게 하나의 객체와 메서드가 많은 형태를 가지고 있는 것을 "**다형성**"이라고 합니다.
7. "**instanceof**"는 객체가 지정한 클래스형의 객체인지를 조사하는 연산자입니다.
