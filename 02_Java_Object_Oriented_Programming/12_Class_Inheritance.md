# 12 클래스의 상속 
- 자바 클래스의 상속을 알아보고, 상속과 관련된 오버라이딩, 추상 클래스, 인터페이스, 다형성을 알아봅니다. 

## 1. 상속 
자바는 객체지향 언어입니다. 그리고 객체 지향 언어의 가장 큰 특징 중 하나가 바로 상속입니다. 
![189_class_inheritance](https://github.com/user-attachments/assets/542a7a30-9904-42aa-9372-2f75b5f30d6e)

상속이란 클래스가 가지고 있는 맴버를 다른 클래스에게 계승시키는 겁니다. 현실 세계에서의 상속과 같습니다. 상속한 멤버는 자식 클래스에서 정의하지 않아도 사용할 수가 있으며, 자식 클래스 내에서 맴버를 추가로 정의해도 사용할 수 있습니다. 게임 속 유닛 상속 관계를 그려보면 위의 이미지와 같습니다. 

상속을 받으면 똑같은 기능을 매번 만들지 않아도 됩니다. 처음부터 모두 새로 준비하는 것보다는 훨씬 간단하고 편리합니다. 이것이 상속이 가지는 편리함입니다. 

상속은 다음과 같은 장점을 제공합니다. 
- 클래스 간의 전체 계층 구조를 파악하기 쉽습니다.
- 재사용성 증대: 기존 클래스에 있는 것을 재사용할 수 있습니다.
- 확장 용이: 새로운 클래스, 데이터, 메서드를 추가하기가 쉽습니다.
  - 예) 고스트, SCV 등 추가할 유닛이 생기면 쉽게 추가할 수 있습니다.
- 유지보수 용이: 데이터와 메서드를 변경할 때 상위에 있는 것만 수정하여 전체적으로 일관성을 유지할 수 있습니다.
  - 예) 종족 간 밸런스를 맞추고자 테란 유닛의 기본 HP를 일괄 변경할 수 있습니다.
 
이때 상속 대상 클래스와 상속을 받은 클래스를 다음과 같이 다양한 이름으로 부를 수 있습니다.

| 상속 대상 클래스 호칭 |  | 상속을 받은 클래스 호칭 |
|:---|:---:|:---|
| 슈퍼 클래스(Supper Class) | &larr;&rarr; | 서브 클래스(Sub Class) |
| 부모 클래스(Parent Class) | &larr;&rarr; | 자식 클래스(Child Class) |
| 기반 클래스 | &larr;&rarr; | 파생 클래스 |
| 조상 클래스 | &larr;&rarr; | 자손 클래스 |
| 상위 클래스 | &larr;&rarr; | 하위 클래스 |

그런데 모든 것을 상속받게 될까요? private으로 접근 제한이 되어 있는 멤버들은 서브 클래스로 상속되지 않습니다. 이것도 현실의 상속과 똑같습니다.

자바에서 이런 자식 클래스를 코드로 구현할 때 다음과 같이 extends 예약어를 사용합니다. 
![190_class_name](https://github.com/user-attachments/assets/5a0dc6f2-0864-465e-b4f0-759316ccefaa)

프로그램에서 어떻게 활용하는지 살펴보겠습니다. 
![191_class_inheritance_example_code](https://github.com/user-attachments/assets/2e9b534a-a69c-4bc4-84c5-316f686cee61)
![192_class_inheritance_example_code_result](https://github.com/user-attachments/assets/6cc797b2-7061-4d51-8429-28077fd50da9)

`Unit`클래스를 부모 클래스로 삼아  `Marine`과 `Medic` 클래스를 정의해 사용하는 예제입니다. 

`1번`먼저 `Unit` 클래스를 정의합니다. 맴버 변수 2개와 메서드 하나를 정의합니다. 
`2번` `Unit`을 상속하여 `Marine` 클래스를 정의합니다. 상속을 통해 부모 클래스의 맴버를 그대로 계승했기에 `Marine`은 맴버 변수로 name, hp, attack 세 개를 사용할 수 있고, 메서드로 printUnit()과 printMarine()을 사용할 수 있습니다. `3번` printMarine() 메서드가 호출되면 `4번` printUnit() 메서드를 호출하고 추가적으로 공격력 정보까지 출력해줍니다. `Marine` 클래스에 printUnit() 메서드가 직접적으로 보이지 않지만 상속받은 기능이기에 이렇게 사용할 수 있는 것입니다.

`5번` `Medic` 클래스에`Unit` 클래스를 상속받아 정의합니다. `6번` `Medic` 클래스에서 사용할 맴버 변수와 `7번` `Medic` 클래스에서 사용할 메서드를 추가합니다. 

`8번` `Marine` 클래스의 객체를 만듭니다. `9번` name과 `10번` hp는 `Marine` 클래스에서는 볼 수 없지만 상속받은 `Unit` 클래스에 정의된 맴버 변수이기 때문에 `Marine` 클래스의 객체에서도 이와 같이 사용할 수 있습니다. 

상속을 받으면 이렇게 부모 클래스의 기능을 구현하지 않고 바로 사용할 수 있어 편리합니다. 

> **자바와 다중 상속**
> 
> 자바는 여러 클래스를 동시에 상속하는 다중 상속을 지원하지 않습니다. 예를 들어 두 개 이상의 상위 클래스에 같은 이름의 메서드가 정의되어 있다면, 다중 상속을 받는 하위 클래스는 어떤 클래스의 메서드를 상속받아 사용해야 할지 헷갈리게 됩니다. 다중 상속을 지원하는 C++ 같은 언어는 이것을 문법적으로 구분해서 사용하지만, 자바는 이런 모호함 자체를 없애기 위해 다중 상속 대신 단계별 상속을 사용합니다.

## 2. 오버라이딩
어떤 메서드명을 만들고 싶은데 이미 부모 클래스에서 사용되었기에 사용할 수 없다고 한다면 메서드명을 짓기가 매우 힘들어질 겁니다. 상속이 부모와 자식 관계뿐 아니라 계속 상속이 일어나서 조상과 후손의 관계까지 된다면 메서드명을 겹치지 않게 만들기가 더욱 힘들게 됩니다(메서드의 오버로딩, 클래스의 맴버 변수와 매개변수를 구분하기 위한 this를 사용할 때도 똑같음). 

오버라이딩(overriding)이란 상속된 메서드와 동일한 이름, 동일한 매개변수를 가지는 메서드를 정의하여 메서드를 덮어쓰는 것을 말하며, 반환값의 데이터 타입도 같아야 합니다.

오버라이딩은 다음과 같이 두 가지 목적으로 사용합니다. 
- 상속받은 부모 클래스 메서드의 기능 변경
- 상속받은 부모 클래스 메서드에 기능 추가

예제를 통해 살펴보겠습니다.

![193_class_overriding_example_code](https://github.com/user-attachments/assets/8913976d-6131-4582-b013-aa0ed8be74df)
<img width="1195" alt="194_class_overriding_example_result" src="https://github.com/user-attachments/assets/9ce6893e-5c2e-4cc7-831d-3e19b1d3e747">

`1번` Unit 클래스에서 doMove() 메서드를 정의했습니다. 그런데 Marine 클래스도 메서드 이름을 doMoveMarine() 보다는 doMove()로 사용하고 싶은 겁니다. 그래서 `2번`처럼 메서드명을 사용했습니다. 이렇게 되면 부모 클래스의 doMove() 메서드와 자식 클래스의 doMove() 메서드가 헷갈리게 됩니다. 그래서 부모에서 상속받은 메서드에는 `super` 예약어를 이용하여 구분해서 불러 줄 수 있게 합니다. Marine 클래스의 doMove() 메서드는 `3번`부모의 doMove() 메서드를 호출하고 `4번` 자체 기능을 추가했습니다. 

그에 반해 Medic 클래스는 `5번`같은 이름으로 doMove() 메서드를 정의했습니다. 그러나 부모의 doMove() 메서드는 따로 호출해주지 않았기 때문에 부모의 기능은 사용하지 않고 자체 구현한 기능만을 사용하게 됩니다.

이처럼 오버라이딩으로 구현한 메서드는 Marine 클래스처럼 기능을 추가하나거나, Medic 클래스 처럼 기능을 대체하게 됩니다. 

## 3. 상속이 제한되는 final 
final은 필드나 메서드, 클래스에 붙이는 예약어입니다. 

```
final int MAX_NUM = 100;
final class Marine
{

}
```

final을 붙였을 때를 정리하면 다음과 같습니다. 

| 상속 대상 클래스 호칭 | 상속을 받은 클래스 호칭 |
|:---|:---|
| 변수 | final 변수는 상수를 의미합니다. |
| 메서드 |  final 메서드는 하위 클래스에서 오버라이딩 할 수 없습니다. |
| 클래스 | final 클래스는 상속을 할 수 없습니다. |

final 상수 때 처럼 클래스도 "이 클래스가 마지막이야! 더 이상 상속하면 안 돼!"라는 의미로 final을 클래스 앞에 붙여준 것이라고 생각하면 됩니다. 

만약 클래스의 일부 메서드를 상속 제한하려면 메서드에 접근 제한자 `private`를 사용합니다.

## 4. 추상 클래스 
여태까지 우리가 만든 메서드들은 구체적인 기능을 가지고 있었습니다. 이런 점에 초점을 맞춰서 메서드를 표현할 때 구상(concrete) 메서드라고 합니다. 반면에 추상(abstract) 메서드라는 것이 있습니다.

구체적인 처리 내용을 기술하지 않고, 호출하는 방법만 정의한 메서드를 추상 메서드라고 합니다. 
```
// 구상 메서드
public int adder (int n1, n2)
{
    return n1 + n2;
}

// 추상 메서드
abstract public int adder (int n1, n2);
```

그리고 이런 추상 메서드를 가진 클래스 추상 클래스라고 합니다. 클래스의 코드 길이가 매우 길 때 중간에 추상 메서드가 하나 있다면 추상 메서드가 있는지 파악이 힘들 수 있습니다. 그래서 `abstract` 표시를 클래스 앞에 붙어 추상 메서드를 가진 클래스라고 표시해줍니다. 

<img width="1200" alt="195_abstract_class" src="https://github.com/user-attachments/assets/9d0b1e83-8d64-4065-89f9-5cc5af9f8785">

만약에 이런 추상 클래스로 객체를 직접 만들게 되면 추상 메서드를 어떻게 동작시켜야 할지 알 수 없기 때문에 추상 클래스로는 객체를 생성할 수 없습니다.

그럼 이런 추상 클래스를 왜 사용하는 걸까요? 상속받은 클래스의 기능을 미리 저장히기 위해서입니다. 이 클래스를 상속받은 클래스는 이런 기능은 반드시 있어야 한다는 것입니다. 그런데 앞으로 어떤 클래스가 상속받을지 모르므로 그 기능을 구체적으로 미리 만들어놓을 수 없을 때 사용합니다. 

앞에서 사용한 Unit 클래스는 유닛의 기본 설계도이므로 테란의 Marine, 프로토스의 Zealot, 저그의 Zergling 클래스는 이 Unit 클래스를 상속해 만들어야 합니다. 셋 다 이동은 해야하니까 유닛에 doMove() 메서드를 만들어놓았습니다. 이러면 상속받은 클래스들은 다 이동에 관련한 기능을 수행할 수 있습니다. 

그런데 세 종족의 이동 방법이 다 다릅니다. 이동 방법이 다 다르기 때문에 미리 기능을 만들어놓아도 오버라이딩해서 기능을 다 수정해야 합니다. 그러므로 미리 이동 기능을 만들어놓은 것은 의미가 없습니다. 다만 혹시라도 까먹고 doMove() 메서드를 구현하지 않을까봐 추상 메서드로 지정해놓습니다. 이러면 상속받은 클래스에서는 추상 메서드를 구상 메서드로 만들지 않으면 객체를 생성할 때 에러가 발생하게 되므로 까먹지 않고 구현하게 됩니다. 

일년이 지나고 나서 다시 유닛이 하나 추가되더라도 상속을 받아 만들게 되면, 추상 메서드의 특성상 이동 기능을 혹시라도 잊고 안 만들면 에러가 나므로 추상 메서드를 구상 메서드로 구현해주게 됩니다. 이렇게 비슷한 객체를 추가할 때 설계 원칙이 유지되는 것입니다. 

예제를 통해 확인해보겠습니다. 
![196_abstract_class_example_code](https://github.com/user-attachments/assets/a432aa4e-c494-472e-b1a0-f6346b3066fd)
![197_abstract_class_example_code_result](https://github.com/user-attachments/assets/0e44cfac-4a11-4886-b34f-3a084ebd929c)

Unit 클래스는 "1번" 4번 라인에서 추상 메서드를 가지고 있으므로 추상 클래스입니다. 그래서 abstract 예약어가 붙어 있습니다. 

이 Unit 클래스를 상속한 "2번" Marine 클래스는 doMove() 메서드의 구체적인 기능을 구현하고 있습니다. 이 Unit 클래스를 상속한 "3번" Zergling 클래스는 doMove() 메서드의 구체적인 기능을 구현하고 있습니다. 

"4번" 객체를 생성하고 "5번" 객체의 메서드를 호출합니다. 

"6번" 객체를 생성하고 "7번" 객체의 메서드를 호출합니다. 

각 클래스에서 추상 메서드를 구상 메서드로 구현한 내용이 출력됩니다.

## 5. 인터페이스 
인터페이스란 상속 관계가 아닌 클래스에 기능을 제공하는 구조입니다. 추상 클래스처럼 추상 메서드로 기능을 제공합니다. 

자바 7까지 인터페이스는 정의와 추상 메서드만을 제공했지만 자바 8부터는 디폴트 메서드, 스태틱 메서드까지 인터페이스 맴버가 될 수 있게 되어 활용성이 높아졌습니다. 인터페이스를 알아보면서 추상 클래스와의 관계도 함께 알아보겠습니다. 

### 5-1. 인터페이스 구현 
인터페이스의 구성을 추상 클래스의 구성과 비교하면 다음과 같습니다.

![198_abstract_class_interface](https://github.com/user-attachments/assets/81c9d230-36bf-4e4c-976d-6cbdca31c5b2)

줄여서 다음과 같이 작성합니다(디폴트 메서드는 뒷 부분에서 따로 다룹니다).

![199_interface](https://github.com/user-attachments/assets/b7720adc-2803-4693-940d-01dadb7e951c)

인터페이스끼리 상속도 가능합니다. 하지만 인터페이스가 일반 클래스를 상속할 수는 없습니다. 

![200_interface_extends](https://github.com/user-attachments/assets/2b8b2672-6fa6-4f75-af60-49906adff8e7)

그리고 인터페이스에 한해서 다중 상속도 가능합니다.

![201_interface_multi_extends](https://github.com/user-attachments/assets/e0fdf075-1b4b-4143-ac4d-09bb7c823025)

인터페이스는 아래와 같이 implements 예약어를 이용해서 코드를 작성합니다. 이후는 추상 클래스의 사용 방법과 동일합니다. 인터페이스의 메서드는 추상 메스드이므로 implements 예약어를 사용했다면 반드시 추상 메서드를 구상 메서드로 오버라이딩해서 구현해주어야 합니다. 이렇게 클래스에서 인터페이스를 이용하도록 하는 것을 '인터페이스 구현'이라고 합니다.

![202_Interface_extend_concrete_class](https://github.com/user-attachments/assets/dacce9e0-c859-4f0a-b18d-b4beb46d76cf)

- 클래스의 상속은 extends 예약어 사용
- 인터페이스의 구현은 implements 예약어 사용

이런 인터페이스는 한 번에 여러 개를 구현할 수도 있습니다. 상속은 다중 상속이 불가능했지만 인터페이스는 다중 구현이 가능합니다. 

![203_multi_interface](https://github.com/user-attachments/assets/8f01a455-6276-4f86-aaf5-ec07926fa391)

상속과 인터페이스를 동시에 사용한다면 아래와 같은 순서를 따릅니다. 앞에서 먼저 상속 표시를 해주고, 뒤에서 인터페이스를 필요한 만큼 표시해줍니다.

![204_multi_intergace_2](https://github.com/user-attachments/assets/27486bde-a612-4d91-8beb-ef29d9358ab5)

인터페이스를 사용하는 간단한 예제를 만들어보겠습니다. 

![205_interface_example_code1](https://github.com/user-attachments/assets/d9b5dec7-6302-40f5-bfa8-8b41f3eaaa2c)

`1번` 추상 메서드 greet()가 있는 인터페이스를 만듭니다. `2번` 추상 메서드 talk()가 있는 인터페이스를 만듭니다. `3번` 아침에 관련된 클래스를 Morning 클래스로 만듭니다. 인사와 인사말을 기능으로 추가합니다. 

`4번` 프로그램이 여기서 시작합니다. `5번` Morning 클래스를 이용하여 객체를 만듭니다. `6번` 참조 변수를 이용하여 인터페이스의 추상 메서드를 구현한 greet() 메서드를 호출합니다. 

`7번` 참조 변수를 이용하여 인터페이스의 추상 메서드를 구현한 talk() 메서드를 호출합니다.

아침에 받드시 인사와 인사말을 나눠야 하는 것은 아닐 겁니다. 클래스 Morning의 본질은 아니라는 이야기입니다. 그냥 Morning 클래스에 단순한 기능을 추가하는 것이므로 기능은 인터페이스로 만들고 그 인터페이스를 구현한 것입니다.
