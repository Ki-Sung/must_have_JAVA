# 16 예외 처리
- 컴파일 오류는 없었지만, 프로그램 실행 시에 에러가 발생할 수 있습니다. 그리고 에러의 발생으로 프로그램이 비정상적으로 종료될 수도 있습니다. 
- 자바에서는 이런 상황을 예외 상황이라 하고 이를 처리하기 위한 예외 처리 방법을 제공합니다.

## 1. 예외와 에러 
우리가 프로그래밍을 할 때 코드에 문법적 오류가 있다면 InteliJ(혹은 다른 IDE)에서 바로 확인이 되거나 컴파일시에 에러가 발생하기 때문에 개발자가 해당 에러를 고칠 수 있습니다. 컴파일 에러는 개발 환경에서 대부분 오류 처리를 하게 됩니다. 그래야 컴파일이 되니까요. 그런데 컴파일 시에는 에러가 발생하지 않았지만 실행 중에 에러가 발생할 수도 있습니다. 예를 들면 나누기인데 사용자가 나누는 수로 0을 입력한 경우입니다. 이렇게 에러는 컴파일 에러(compile error)와 런타임 에러(runtime error)가 발생할 수 있습니다. 

![316_exception_structure](https://github.com/user-attachments/assets/1722cfa5-c494-4a00-9865-ec8540afebf7)

프로그램 실행 중에 발생하는 런타임 에러는 자바 가상 머신에서 발생하는 시스템 에러로 예측하기 어려운 경우도 있고, 반면에 예측할 수 있는 것도 있습니다. 시스템 에러는 사용 가능한 메모리가 부족하다거나, 운영체제에서 발생한 에러로 프로그램이 영향을 받게 되는 경우입니다. 이러한 시스템 에러는 개발자가 프로그램에서 제어할 수 없습니다. 

예측이 가능한 런타임 에러를 예외(exception)라고 부릅니다. 그리고 개발자가 다음과 같은 목적을 위해 제어하고 처리를 합니다. 

1. 프로그램 정상 종료
2. 예외 발생 시 무시하고 프로그램 계속 실행

자바에서 제공하는 에러에 대한 전체 클래스를 간단히 나타내면 다음과 같습니다. 프로그램에서 처리하는 예외 클래스의 최상위 클래스는 Exception 클래스 입니다. 그리고 모든 예외 타입은 클래스로서 서로 상속 관계입니다.

![317_exception_structure2](https://github.com/user-attachments/assets/017e53c9-249a-4bf6-af95-4648fd717701)

## 2. 예외 종류 
예외는 다음과 같이 실행 예외와 일반 예외로 한번 더 구분됩니다. 
- 실행 예외
  - 예외 처리를 하지 않아도 컴파일할 수 있는 비검사형 예외(unchecked exception)
  - 실행 단계에서 체크
- 일반 예외
  -  예외 처리를 하지 않으면 컴파일 오류가 발생하므로 꼭 처리해야 하는 검사형 예외(checked exception)
  -  컴파일 단계에서 체크
 
이처럼 예외를 구분하는 이유는 프로그램 성능 때문입니다. 모든 상황에서 예외 처리를 하면 프로그램의 성능 저하 문제로 이어지기 때문에 일반 예외는 컴파일러가 확실히 확인하고, 실행 예외는 개발자가 판단하여 예외를 처리하든지 처리가 안 되었다면 자바 가상 머신에 처리를 맡기게 됩니다. 

- 대표적인 실행 예외

| 실행 예외 | 발생 이유 | 
|:---|:---|
| ArtithmeticException | 0으로 나누기와 같은 부적절한 산술 연산을 수행할 때 발생합니다. |
| IllegalArgumentException | 메서드에 부적절한 매개변수를 전달할 때 발생합니다. | 
| IndexOutOfBoundException | 배열, 벡터 등에서 범위를 벗어난 인덱스를 사용할 때 발생합니다. | 
| NoSuchElementException | 요구한 원소가 없을 때 발생합니다. | 
| NullPointerException | null값을 가진 참조 변수에 접근할 때 발생합니다. | 
| NumberFormatException | 숫자로 바꿀수 없는 문자열을 숫자로 변환하려 할 때 발생합니다. | 

- 대표적인 일반 예외

| 일반 예외 | 발생 이유 | 
|:---|:---|
| ClassNotFoundException | 존재하지 않는 클래스를 사용하려고 할 때 발생합니다. | 
| NoSuchFieldException | 클래스가 명시한 필드를 포함하지 않을 때 발생합니다. | 
| NoSuchMethodException | 클래스가 명시한 메서드를 포함하지 않을 때 발생합니다. | 
| IOException | 데이터 읽기 쓰기 같은 입출력 문제가 있을 때 발생합니다. | 

### To Do 일반 예외와 실행 예외를 살펴보기 
#### 01 Ex01_ExceptionCase 클래스를 만들어 다음과 같이 코드를 입력합니다.
![318_exception_case_example](https://github.com/user-attachments/assets/d87b3681-be1b-4d0d-8fa6-db37ee5112c7)

`1번`입력되는 숫자가 0일 때만 11번 라인에서 수학적 오류로 예외가 발생합니다. 사용자의 입력 값에 따라 에러가 발생할 수도 있고 발생하지 않을 수도 있습니다. 그렇기 때문에 이런 실행 예외는 개발자에게 판단과 처리를 맡깁니다. 개발자가 처리를 안한 경우 자바 가상 머신은 예외 발생 시 프로그램을 안정적으로 종료시킵니다.

`2번`의 코드 자체는 문법적 오류가 없이 잘 작성되었습니다. 그러나 참조할 MyBook 클래스가 컴파일을 할 때나 실행 중에 없다면 무조건 에러가 발생하게 됩니다. 그렇기 때문에 이런 일반 예외는 무조건 예외 처리를 해주어야 합니다. 

#### 02 저장하고 컴파일 하세요. 그러면 에러가 납니다. 현재 MyBook() 정의가 없어 그렇습니다. 
![319_exception_case_example_result_error1](https://github.com/user-attachments/assets/7c4c3137-fdeb-4086-a77a-603b058b855b)

#### 03 앞에서 작성한 코드에서 `2번` 14라인만 주석 처리하고 컴파일하고 실행해보겠습니다.
#### 04 실행이 되면 콘솔창에서 숫자 0을 입력해봅니다. 다음과 같은 에러가 발생합니다.
![320_exception_case_example_result_error2](https://github.com/user-attachments/assets/4c1bdbf7-229a-46d1-ae84-e15dc49b3657)

&rarr; ArithmeticException(0으로 나누기와 같은 부적절한 산술 연산 수행시 발생하는 실행 예외)이 발생합니다.

#### 05 다시 실행하고 이번에는 문자 A를 입력해봅니다. 다음과 같은 에러가 발생합니다. 
![321_exception_case_example_result_error3](https://github.com/user-attachments/assets/14b09d94-efe1-48f3-a7d2-e5b501fe92a7)

이것이 실행 예외입니다. 발생하지 않을 수도 있기에 별도의 예외 처리를 하지 않아도 컴파일은 되지만, 실행 시 이런 값이 입력된다면 이렇게 비정상적인 종료를 하게 됩니다. 

## 3. 예외 처리하기 
예외 처리 진행 형식은 다음과 같습니다.
```
try
{
    JAVA 코드
}
catch (예외 타입 1 e)
{
    예외 1 발생 시 이 부분 실행
}
catch (예외 타입 2 e)
{
    예외 2 발생 시 이 부분 실행
}
finally
{
    이 부분은 마지막에 무조건 실행 
}
```

다음과 같이 일부분을 생략하고 작성할 수도 있습니다. 
```
try
{
    JAVA 코드
}
catch (예외 타입 e)
{
    예외 발생 시 이 부분 실행
}

try
{
    JAVA 코드
}
finally 
{
    이 부분은 마지막에 무조건 실행 
}
```

### 3-1. try ~ catch
앞에서 작성한 코드의 예외는 두 개이므로 다음과 같이 코드를 추가하여 예외를 처리해주도록 합니다. 
![322_try_catch_example](https://github.com/user-attachments/assets/39da1abb-6467-4a34-9d5e-c31345385a0f)

`2번`에서 `5번`까지 예외 처리를 위해 try문의 중괄호로 묶었습니다. 이 부분을 실행하다 예외가 발생하면 해당 예외에 대한 catch문이 실행되게 됩니다. if ~ else if ~ else if ~ 와 비슷하다고 생각하면 됩니다.

`1번` java.util.InputMismatchException을 `8번`에 사용하는 InputMismatchException을 위해 먼저 임포트합니다. 입포트 없이 `8번`을 사용하면 컴파일 에러가 발생합니다. 

`6번`catch문은 `3번`에서 수학적인 처리에 대한 예외가 발생하면 실행됩니다. `7번`예외에 대한 간단한 메시지를 문자열로 받아옵니다.
![325_try_catch_example_result3](https://github.com/user-attachments/assets/93b0fe6b-26fd-4a6a-a98b-0a3a14fa1e50)

`8번`catch문은 `2번`에서 입력값이 정수가 아니어서 데이터의 형변환에 대한 예외가 발생하면 실행됩니다. `10번`예외에 대한 자세한 메시지를 출력합니다. 
![323_try_catch_example_result1](https://github.com/user-attachments/assets/50acfec2-c01c-4b03-b6a7-0f8344b29b5c)

이처럼 예외가 발생한 지점에서 catch문으로 실행 지점이 이동하게 됩니다. 그러므로 예외가 발생하면 `4번`과 `5번`은 실행되지 않습니다.

실행을 하고 콘솔청에서 문자 A를 입력해봅니다. `2번`에서 입력 시 예외가 발생하고, `8번`catch문이 실행되고 `9번`에서 에러 메시지를 얻어서 출력해줍니다. 결과에서 보듯이 `4번`과 `5번`코드는 실행되지 않았습니다. 
![324_try_catch_example_result2](https://github.com/user-attachments/assets/68ecc1bf-2b2e-4489-8b45-821f203d7591)

### 3-2. finally 
예외가 발생해도 바로 앞 예제의 `5번`을 무조건 실행하고 싶다면 다음과 같이 finally문을 추가하고 그쪽으로 코드를 이동해주어야 합니다. 

<img width="898" alt="326_finally_example" src="https://github.com/user-attachments/assets/7322f7e0-d0f3-44c3-aaf4-daf0dcb75f7c" />


예외가 발생해도 반드시 실해되어야 하는 문장이라면 위 코드와 같이 finally문 안에 작성을 해주면 됩니다. try문을 실행하다 예외가 발생하면 예외 발생 지점에서 catch문으로 실행이 이동하게 되지만 catch 영역이 실행되고 맨 마지막에 finally문의 내용이 반드시 실행됩니다. 

실행을 하고 콘솔창에 문자 A를 입력해봅니다. `1번`이나 `2번`에서 입력 시 예외가 발생해도 `3번`은 반드시 실행되면서 내용이 출력됩니다.

<img width="900" alt="327_finally_example_result" src="https://github.com/user-attachments/assets/ad97864e-e9cd-41a7-b743-9c7917b7ff9f" />

### 3-3. 예외처리 합치기
예외 상황에 대해서 catch문 하나당 예외 하나를 처리할 수도 있지만, catch문 하나에서 여러 예외를 한꺼번에 처리할 수도 있습니다. 
<img width="883" alt="328_catch_concat_example" src="https://github.com/user-attachments/assets/c7a314ed-34ab-48dd-ab4e-a567a4337bbb" />
<img width="870" alt="329_catch_concat_example_result" src="https://github.com/user-attachments/assets/a386de1d-7a0f-4fe0-b3cc-1ca97b2c3e5d" />

실행을 하고 콘솔창에서 문자 A를 입력해보니 예상대로 예외 처리가 작동합니다. 

`1번` 여러 Exception을 버티컬 바(`|`)를 이용해 지정하고 있습니다(`|`는 or 연산자입니다).

`2번` 여러 상황에 대한 자세한 메시지 처리 대신, 모든 상황을 간단한 메시지로 한 번에 처리하고 있습니다. 

`3번` finally를 꼭 통하지 않더라도 try ~ catch 문에 의해 비정상적인 종료는 방지되었으므로 그 뒤에 이렇게 사용하면 이 내용을 예외가 발생해도 출력할 수 있습니다.

### 3-4. 모든 예외 한 번에 처리하기 
어떤 예외가 발생할지 모를 때 모든 예외의 최상위 클래스를 이용해서 예외를 처리해줄 수 있습니다. 클래스의 다형성에서 배운 '자식 클래스의 객체는 부모 클래스형의 변수에 대입할 수 있다'가 적용되어 모든 예외를 처리할 수 있게 됩니다.

<img width="899" alt="330_exception_example" src="https://github.com/user-attachments/assets/5cae4730-ef94-4905-b884-4a8cdc51bfb3" />
<img width="880" alt="331_exception_example_result" src="https://github.com/user-attachments/assets/29d84169-54c5-4741-84a7-5290eca54971" />

A를 입력한 결과 예상대로 예외 처리가 작동합니다. 

예외를 한 번에 다 처리하려면 `1번`의 Exception 클래스나 Throwable 클래스를 사용할 수 있습니다. 모든 예외 Exception 클래스를 상속받은 것이기 때문에 다형성에서 배운 것 처럼 수많은 예외 클래스들은 `1번`의 매개변수 Exception e에 대입이 될 수 있습니다.

## 4.예외 처리 미루기(던지기)
예외가 발생한 메서드에서 처리하지 않고 메서드를 호출한 곳으로 예외를 던져 메서드를 호출한 부분에서 예외를 처리하는 방법입니다. 
![332_exception_throw_structure](https://github.com/user-attachments/assets/1ba374d8-ca0d-40ba-a3db-4f6b1abced65)

myMethod2에서 try ~ catch문으로 예외를 직접 처리할 수도 있지만 예외 처리를 미룰 수도 있습니다. 그러면 myMethod2()를 호출한 myMethod()에서 예외를 처리해야 합니다. 

myMethod()에서도 예외 처리를 미루면 예외는 main()으로 전달됩니다. main()에서도 예외 처리를 미루면 예외는 JVM으로 전달되고 JVM은 프로그램을 종료시킵니다. 

### 4-1. 예외처리 미루기 
예외 처리가 어떻게 미루어지는지 예제를 통해 살펴보겠습니다. 
![333_exception_throw_example](https://github.com/user-attachments/assets/81c17461-c58b-4e92-98aa-a39acbd81402)
![334_exception_throw_example_result](https://github.com/user-attachments/assets/7a6cc7b1-3af4-4453-ad5f-362b446381d6)

`1번`에서 0으로 나누기 때문에 예외가 발생합니다. 그런데 예외에 대한 처리를 하지 않았기 때문에 myMethod2()를 호출한 myMethod()로 예외가 던져집니다. 그런데 myMethod()에서도 예외 처리가 안 되어 있기 때문에 예외는 myMethod() 메서드를 호출한 main()으로 다시 던져집니다. main()에서도 예외에 대한 처리가 되어 있지 않기 때문에 예외를 자바 가상 머신에 던지게 됩니다. 이 라인에서 프로그램은 종료하게 되고, 그래서 `2번`은 실행되지 못합니다. 

콘솔창의 에러를 보면 에러가 발생한 지점을 보여주는 at에서 처음에 9번 라인에서 에러가 발생했다고 표시하고 있습니다. 그리고 5번 라인, 그다음으로 13번 라인에 에러라고 표시하고 있습니다. 예외가 던져진 지점하고 일치 합니다. 

### 4-2. Throwable로 잡기
던져진 예외를 처리하려면 어떤 예외가 올지 모르므로 catch문에서 앞선 Exception을 사용할 수도 있겠지만, 던져진 것을 처리한다는 의미로 Exception의 상위 객체인 Throwable을 사용할 수도 있습니다.

![335_catch_throwable_example](https://github.com/user-attachments/assets/8c18ec43-5119-4846-a076-b71f8f41bfee)
![336_catch_throwable_example_result](https://github.com/user-attachments/assets/c3bc5aa0-ee77-46ea-a7bd-28edd03f8de8)

`2번`숫자가 아닌 글자들을 입력받으면 예외가 발생합니다. `3번`에서는 `2번`에서 정수 0이 입력되면 나누기를 하다가 예외를 발생합니다. 

try ~ catch문을 이용하여 예외를 처리하지는 않았지만 `2번`과 `3번`에서 예외가 발생하면 메서드를 호출한 지점으로 예외가 전달됩니다. 이렇게 전달된 예외는 최종적으로 `5번` catch문 안 Throwable e 매개변수에 대입됩니다. 

에러를 볼 때 다음과 같이 콘솔창에서 에러의 맨 아래줄부터 위로 올라오면서 해당 줄의 코드를 살펴보면 에러가 발생한 지점을 찾을 수 있습니다. 

맨 처음 20번 라인에서 에러가 발생했습니다. myMethod() 메서드를 호출하는 부분입니다. 

그리고 7번 라인에서 에러가 발생했습니다. myMethod() 메서드 안에서 myMethod2() 메서드를 호출하는 부분입니다. 그리고 14번 라인에서 에러가 발생합니다. myMethod2() 메서드 안에서 입력받은 수로 나누기를 하는 부분입니다. 

이렇게 예외가 던져진 것을 반대로 찾아 가면 에러가 발생한 지점을 찾을 수 있습니다.

### 4-3. 예외 처리를 미루는 이유
그렇다면 왜 예외처리를 미루는 걸까요? 그냥 이런 문법이 있다고 알면 실전에서 사용할 수 없습니다. 그 이유를 알아야 합니다. 예외를 전달하여 처리하는 이유는 예외가 발생하는 지점의 메서드를 많은 곳에서 호출하는 경우 예외 처리가 다양할 수 있기 때문입니다. 

예를 들어 클래스에서 스태틱으로 지정된 유틸 메서드인 경우는 어떤 클래스의 메서드가 자신을 호출할지 모르는 상태이기 때문에, 호출하는 쪽에서 예외 처리를 해야 더 적절한 처리를 할 수 있습니다. 
###### * 스태틱 메서드 - 클래스에 속하지만 인스턴스를 생성하지 않고 호출할 수 있는 메서드
###### * 유틸 메서드 -  일반적으로 특정 기능을 수행하는 메서드로, 특정 클래스와 관련이 없거나 여러 클래스에서 공통적으로 사용할 수 있는 기능을 제공
![337_why_trhow_examplea](https://github.com/user-attachments/assets/cc634697-fd59-4a15-b779-95cf8c1fe10e)
![338_why_trhow_examplea_result](https://github.com/user-attachments/assets/8658f209-4eaf-4a8b-bf86-f7a3d4bbad99)

`1번`과 `2번` 둘 다 myMethodA() 메서드를 호출해서 같은 예외가 발생한 상황이지만 myMethod()와 myMethod2()는 예외를 전달받아 서로 다른 예외를 처리할 수 있습니다. 그렇기에 처리하는 메시지 형태가 이렇게 달라질 수 있습니다. 

### 4-4. 메서드에 예외 선언
메서드 선언부에 예외를 써주는 문법이 있습니다. 

```
public static void 메서드명()
    throws 예외, 예외, 예외
{
    // 본문
}
```

메서드의 선언부에 예외를 선언하면 어떤 이점이 있을까요? 메서드를 사용하는 사람이 메서드의 선언부만 보아도 이 메서드를 사용하려면 어떤 예외들을 처리하면 되는지 쉽게 알 수 있게 됩니다. 

메서드에 예외를 선언할 때 일반적으로 RuntimeException 클래스들은 적지 않습니다. 이들은 메서드 선언부의 throws에 선언한다고 해서 문제가 되지는 않지만, 보통 반드시 처리해주어야 하는 예외들만 선언합니다.

![339_throws_in_method_example](https://github.com/user-attachments/assets/5be74a6d-b0c8-4f10-a830-ce3ecee9c92a)
![340_throws_in_method_example_result](https://github.com/user-attachments/assets/51313157-ec77-4339-b6c5-bdcd97d7cf15)

`2번` myMethod2() 메서드의 정의 부분만 보더라도 이 메서드는 ArithmeticException, InputMismatchException 예외가 발생한다는 것을 알 수 있습니다. 

반면에 `1번` myMethod() 메서드는 예외가 발생하면 자신을 호출한 메서드로 예외를 던져주기는 하겠지만 이 부분만 보아서는 어떤 예외가 발생할지는 알 수 없습니다. 

메서드에 예외를 선언할 때 일반적으로 실행 예외 클래스들은 적지 않고, 보통 반드시 처리해주어야 하는 일반 예외 클래스들만 선언합니다. 앞에서 우리가 다루었던 예제들 대부분이 메서드에 예외 선언을 하지 않았습니다. 하지만 조금 전 설명처럼 의미의 전달이 확실해진다는 장점을 살려 메서드에 예외 선언을 할 수도 있습니다. 

그리고 실행 예외 클래스들을 메서드의 throws에 선언한다고 해서 문제가 되지는 않습니다. 

## 학습 마무리
### 핵심 요약 
1. 에러는 발생 시점에 따라 컴파일 에러와 런타임 에러가 있습니다.
2. 컴파일 오류는 없지만, 프로그램 실행 시에 에러가 발생할 수 있습니다. 그리고 에러의 발생으로 프로그램이 비정상적으로 종료될 수도 있습니다. 이런 상황을 예외 상황이라 합니다.
3. try ~ catch문으로 예외를 처리합니다.
4. 예외가 발생해도 무조건 실행하고 싶다면 finally문을 추가하고 코드를 이동해주어야 합니다.
5. 던져진 예외를 처리하려면 catch문에서 Throwable 클래스를 이용해야 합니다.
6. 예외를 전달하여 처리하는 이유는 예외가 발생하는 지점의 메서드를 많은 곳에서 호출하는 경우 예외 처리가 다양할 수 있기 때문입니다.
7. 메서드 선언부에 예외를 써주는 문법이 있습니다. 메서드의 선언부만 보아도 이 메서드를 사용하려면 어떤 예외들을 처리하면 되는지 쉽게 알 수 있기 때문입니다.
8. 예외는 다음과 같이 실행 예외와 일반 예외로 한 번 더 구분됩니다.
   - 실행 예외
     - 예외 처리를 하지 않아도 컴파일할 수 있는 비검사형 예외
     - 실행 단계에서 체크
   - 일반 예외
     - 예외 처리를 하지 않으면 컴파일 오류가 발생하므로 꼭 처리해야 하는 검사형 예외
     - 컴파일 단계에서 체크 
